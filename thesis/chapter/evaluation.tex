\pagestyle{fancy}
\normalsize
\linespread{1.5}\selectfont
\chapter{实现细节与评估}
\addtocontents{los}{\protect\addvspace{10pt}}

\section{实现细节}
在PLT Redex中，对一个语言的定义主要需要三个内容。
\begin{itemize}
	\item 文法
	\item 上下文环境
	\item 规约规则
\end{itemize}

我们在实现中，对所有表达式按如下文法进行子类划分。
\begin{verbatim}
exp ::= coreexp | surfexp | commonexp
\end{verbatim}

与(第三章第1节)的定义有所差别的是，这里的surfexp包括了第三章第1节的Surfexp和OtherSurfexp，commonexp包括了第三章第一节的Commonexp和OtherCommonexp。

对于coreexp，自然是包含了所有内部语言的术语。因为我们的定义是将Exp的形式限制在$(Headid\;Subexp_{1}\ldots)$，通常情况下可以根据Headid判断是否是coreexp。

例：
\begin{verbatim}
coreexp ::= (if exp exp exp)
		|   (let ((x exp) ...) exp)
		|   (first exp)
		|   (rest exp)
		|   ...
\end{verbatim}

对于surfexp，就是$Headid$是表示DSL的标识的表达式。

例：
\begin{verbatim}
surfexp ::= (and exp exp)
		|   (or exp exp)
		|   (map exp exp)
		|   (filter exp exp)
		|   ...
\end{verbatim}

对于commonexp，是为了让我们的重组糖序列中有一些包含在内部语言、但是可以输出的中间过程。例如对于高阶糖

$(Map\;f\;lst)-->(cons\;(f\;(first\;lst))\;(Map\;f\;(rest\;lst)))$

\begin{flushleft}
	我们需要一些中间序列用cons表示，来输出有用的中间过程。我们主要需要的commonexp有所有值、所有基础运算（包括算数运算和列表运算）。
\end{flushleft}

对于上下文规则，对coreLang为了限制每个表达式只有一条规则可以规约，需要仔细限制位置。
而对于surfLang，由于我们不知道哪个子表达式需要先规约，要把每一个位置都设为可规约的洞。
\begin{verbatim}
(E  (v ... E e ...)
	(let ((x v) ... (x E) (x e) ...) e)
	(if E e e)
	(and E e)
	(and e E)
	(or E e)
	(or e E)
	...
	hole)
\end{verbatim}

规约规则没有特殊说明。具体可参见代码。\footnote{\url{https://github.com/yangdinglou/Lightweight-Resugaring-using-PLT-Redex}}

\pagebreak
\section{评估}

\subsection{普通糖}

我们首先就简单的

$(and\;e1\;e2)-->(if\;e1\;e2\;\#f)$

$(or\;e1\;e2)-->(if\;e1\;\#t\;e2)$
糖进行测试。

因为我们的CoreLang上规定的求值顺序是，对$(if \;e1\;e2\;e3)$的$e1$求到值后就规约，因此我们应该看到的是对$and$和$or$糖，先将第一个值求到值，如何对糖进行破坏。

\framebox[30em][l]{
\parbox[t]{\textwidth}{
	(and (and \#t \#f) (or \#f \#t))\\
	(and \#f (or \#f \#t))\\
	\#f
}
}

\framebox[30em][l]{
	\parbox[t]{\textwidth}{
		(and (or \#f \#t) (or \#f \#f))\\
		(and \#t (or \#f \#f))\\
		(or \#f \#f)\\
		\#f
	}
}

我们可以看到如上的两个例子皆按照我们预想的样子输出了重组糖序列。\\[6pt]

另外尽管我们的重组糖序列不考虑有副作用的语言，但我们依然测试了一下考虑副作用时的糖的正确性。

$(Myor\;e1\;e2)-->(let\;((tmp\;e1))\;(if\;tmp\;tmp\;e2))$
其中没有用到任何其他糖，因此我们可以期待它的效果和上面的or糖一样。

\framebox[30em][l]{
	\parbox[t]{\textwidth}{
		(Myor (Myor \#f \#f) (and \#t \#t))\\
		(Myor \#f (and \#t \#t))\\
		(and \#t \#t)\\
		\#t
	}
}
结果显示我们的方法确实正确得到了该重组糖的序列。

\subsection{复合糖}

尽管和普通糖没有本质区别，但本节测试的糖在解糖后依然存在语法糖结构。我们构造如下Sg糖为例

$(Sg\;e1\;e2\;e3)-->(and\;(or\;e1\;e2)\;(not\;e3))$

\framebox[30em][l]{
	\parbox[t]{\textwidth}{
		(Sg (and \#t \#f) (not \#f) \#f)\\
		(Sg \#f (not \#f) \#f)\\
		(and (or \#f (not \#f)) (not \#f))\\
		(and (not \#f) (not \#f))\\
		(and \#t (not \#f))\\
		(not \#f)\\
		\#t
	}
}
\subsection{卫生宏}

\subsection{递归糖}

\subsection{高阶糖}

\section{一些其他讨论}

\subsection{副作用}