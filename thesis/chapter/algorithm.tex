\pagestyle{fancy}
\normalsize
\linespread{1.5}\selectfont
\chapter{算法定义及正确性证明}
\addtocontents{los}{\protect\addvspace{10pt}}

\section{对语言的规定}
{\bfseries 首先}，我们需要将整个语言限定在基于树形表达式的结构化语言。

树形表达式：此处我们使用类似Lisp的S表达式的递归树，基础定义如下。

\framebox[20em][l]{%  
	Exp::=\parbox[t]{\textwidth}{%
		\begin{flushleft}  
			(Headid~Exp*)\\  
			|Value\\
			|Variable
		\end{flushleft}  
	}%  
}  

结构化：对于每个表达式中的子表达式，其规约规则只和子表达式本身有关。此限制约束了Corelang的作用域，限制语言子表达式不能有对外的副作用。我们将在第五章详细讨论副作用的一些具体解决办法

{\bfseries 此外}：我们对CoreLang和SurfLang进行一些简单的限制。

对每个子表达式都是CoreLang表达式的表达式Exp，最多只能有一条规约路径（通过求值顺序约束）。这一点约束并不过分，为了保证每个程序只能有一条执行路径。

对SurfLang，任意一个语法糖只能有一个CoreLang的表达式与之对应。这也是很自然的要求，因为同一个语法糖不应该有二义性。对于求值顺序，SurfLang上的子表达式约定类似完全规约的规则，任何子表达式都可以首先进行规约。

在PLT Redex中，我们将CoreLang和SurfLang视为同一个语言。则当我们定义了一个语言内部各种规约规则后，对于任意Exp都有其对应的一条或多条规约规则。根据对CoreLang的约定，有多条规约规则的表达式必然存在SurfLang的表达式。

为了区分CoreLang的语言和SurfLang的语言，我们将表达式的文法定义为如下

\framebox[30em][l]{%  
	\parbox[t]{\textwidth}{
		\begin{flushleft}
			Exp::=\parbox[t]{\textwidth}{
				\begin{flushleft}  
					Coreexp\\
					|Surfexp\\
					|Commonexp\\
					|OtherSurfexp\\
					|OtherCommonexp
				\end{flushleft}  
			}\\
			Coreexp ::= (CoreHead Exp*)\\
			Surfexp ::= (SurfHead (Surfexp|Commonexp)*)\\
			Commonexp::=\parbox[t]{\textwidth}{
				\begin{flushleft}
					(CommonHead (Surfexp|Commonexp)*)\\
					|value\\
					|variable
				\end{flushleft}	
			}\\
			OtherSurfexp ::= (SurfHead Exp* Coreexp Exp*)\\
			OtherCommonexp ::= (CommonHead Exp* Coreexp Exp*)
		\end{flushleft}
	
}
	
}  

在这里，我们将CoreLang的表达式一部分提取处理作为公共表达式，是因为在重组糖序列中必定有一些表达式是属于CoreLang的，但需要在序列中输出（比如说数字，布尔表达式，以及一些可能的基础运算）。在这种情况下，对于Commonexp来说，满足CoreLang的约束，但是也可以作为重组糖的中间序列输出

可以看出，在我们的重组糖方法中，可以输出的表达式是Surfexp和Commonexp，即不存在任何子表达式中存在Coreexp。

{\bfseries 小结：}todo
\newpage

\section{算法描述}
本节讨论建立在符合约定的语言基础上。

{\bfseries 核心算法f}\footnote{核心思想：对于每个表达式Exp，我们将对它所有规约规则中选择一条符合resugaring的仿真性规则的规约，且尽可能不破坏任何语法糖。}定义如下：（输入为一个任意Exp，输出为应用应该执行的规约规则后的表达式）

\begin{flushleft}
\fbox{
	\parbox{\textwidth}{
	对Exp尝试所有规约规则，得到多个可能的表达式ListofExp'=\{$Exp'_{1}$,$Exp'_{2}$,$\ldots$\}
	
	\begin{flushleft}
		\large{\bfseries{
				1.	如果Exp是Coreexp或Commonexp或OtherCommonexp，则其规约规则	
			}	
		}	
	\end{flushleft}
	\begin{itemize}
		\item 或是将表达式规约到另一个表达式，此时只有一条规则，应用后输出Exp';
		\item 或是其规约不满足导致内部子表达式需要规约，此时因为CoreLang的定序性，只会有一个子表达式被规约（且此表达式为Surfexp），此时对该子表达式Subexp递归调用核心算法f得到Subexp’，则在ListofExp'中找到将此Exp中子表达式Subexp规约为Subexp’的表达式就是我们需要的表达式；
		\item 或是已经无法被规约（ListofExp'为空），此时返回的表达式为空。
	\end{itemize}

	\begin{flushleft}
		\large{\bfseries{
				2.	如果Exp是Surfexp或OtherSurfexp	
			}	
		}
	\end{flushleft}
	\begin{itemize}
		\item 如果内部子表达式无可规约的，则必然会展开该语法糖，此时输出表达式为Exp解糖后的表达式;
		\item 如果存在可规约的子表达式对于每个子表达式，如果可规约，则根据我们的设定，存在一条关于此子表达式的规约规则。因此每个子表达式都可能被规约的前提下，我们需要对Surfexp或OtherSurfexp的语法糖进行展开为Exp’（此展开只有一种规约规则对应），之后对Exp’调用核心算法f，检测内部哪个子表达式Subexp在f调用过程中被规约，则此子表达式Subexp需要在Exp处首先被规约，对应对该子表达式被规约的表达式。
	\end{itemize}
	}
}
\end{flushleft}
\pagebreak

{\bfseries 整体算法lightweight-resugaring}定义如下

算法Lightweight-resugaring：给定Surfexp的表达式$Exp$，输出其重组糖序列\\

\fbox{
\parbox{\textwidth}{
	$Lightweight-resugaring$($Exp$)
	
	\qquad while($tmpexp$==f($Exp$)))
	
	\qquad \qquad if($tmpexp$ is empty):
	
	\qquad \qquad \qquad return;
	
	\qquad \qquad else if($tmpexp$ is surfexp or commonexp):
	
	\qquad \qquad \qquad output $tmpexp$;
	
	\qquad \qquad else:
	
	\qquad \qquad \qquad $Lightweight-resugaring$($tmpexp$)
}
}

\section{正确性证明}
\subsection{仿真性}

\subsection{抽象性}
抽象性的正确性是显然的，因为我们在每次输出都判断了输出的$Exp$是否是$Surfexp$或$Commonexp$。

\subsection{覆盖性}



