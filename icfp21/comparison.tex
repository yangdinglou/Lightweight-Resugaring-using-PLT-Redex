%!TEX root = ./main.tex
\section{Extensions}
\label{sec5}
\ycomment{}
\subsection{Model Assumption and A Black-Box Extension}


As we mentioned in the introduction (Section \ref{mark:mention}), our approach assumes a more specific model (evaluation rules) compared to the existing approach (black-box stepper). Here is a small gap between the motivation of the existing approach and ours---the existing approach focused mainly on a tool for existing language, while our approach considered more on a meta-level feature for language implementation. Some examples in next chapter will show how the lazy desugaring solves some problems in practice.

In addition, as what we need for the lazy desugaring is just the computational order of the syntactic sugar, we can make an extension for the resugaring algorithm to work with only a black-box core language stepper. The most important difference between the black-box stepper and the evaluation rules is the computational order---while the same language behaves uniquely, the evaluation rules can show the computational order statically (without running the program). So when meeting the black-box stepper for the core language, we can just use some simple program to "get" the computational order of the core language as the following example  shows: we simply let the sub-expressions of a \m{Head} be some reducible expressions and test the computational order.

\begin{center}\footnotesize
	\Code{(if $\m{tmpe}_1$ $\m{tmpe}_2$ $\m{tmpe}_3$)}\\ $\Downarrow_{stepper}$\\ \Code{\qquad\qquad\qquad\qquad\;\;(if $\m{tmpe}_1$' $\m{tmpe}_2$ $\m{tmpe}_3$)}\note{//getting a context rule}\\ $\Downarrow_{getnext}$\\ \Code{(if $\m{tmpv}_1$ $\m{tmpe}_2$ $\m{tmpe}_3$)}\\ $\Downarrow_{stepper}$\\ \qquad\Code{$\m{tmpe}_i$}\note{//no more rules}\\
\end{center}


But that's not enough---the core language and the surface language cannot be mixed easily because of the lack of evaluation rules for the core language. We should do the same try during the evaluation to make the core language's stepper useful when meeting some surface language's expression. Here we give a dynamic on-step reduction of the mixed language. Note that here we only define the reduction for unnested syntactic sugar for convenience. It is easy to extend to nested sugar (but so huge to express). 

\begin{Def}[Dynamic mixed language's one-step reduction $\redm{}{}$] Defined in Fig.  \ref{fig:dynamic}.
\end{Def}
\begin{figure*}[t]\footnotesize
\infrule[CoreRed]
{ \forall~i.~e_i\in \m{CoreExp}\\
\redc{(\m{CoreHead}~e_1~\ldots~e_n)}{e'}}
{\redm{(\m{CoreHead}~e_1~\ldots~e_n)}{e'}}
\infrule[CoreExt1]
{ \forall~i.~tmp_i= (e_i \in \m{SurfExp}~?~\m{tmpe}~:~e_i)\\
\redc{(\m{CoreHead}~tmp_1~\ldots~tmp_i~\ldots~tmp_n)}{(\m{CoreHead}~tmp_1~\ldots~tmp_i'~\ldots~tmp_n)}}
{\redm{(\m{CoreHead}~e_1~\ldots~e_i~\ldots~e_n)}{(\m{CoreHead}~e_1~\ldots~e_i'~\ldots~e_n)}\\where~\redm{e_i}{e_i'}}
\infrule[CoreExt2]
{ \forall~i.~tmp_i= (e_i \in \m{SurfExp}~?~\m{tmpe}~:~e_i)\\
\redc{(\m{CoreHead}~tmp_1~\ldots~tmp_n)}{e'}~\note{// not reduced in sub-expressions}}
{\redm{(\m{CoreHead}~e_1~\ldots~e_n)}{e'[e_1/tmp_1~\ldots~e_n/tmp_n]}}
\infrule[SurfRed1]
{\drule{(\m{SurfHead}~x_1~\ldots~x_i~\ldots~x_n)}{e}~\\
\exists i.\, \redm{e[e_1/x,\ldots,e_i/x_i,\ldots,e_n/x_n]}{e[e_1/x,\ldots,e_i'/x_i,\ldots,e_n/x_n]}~\&~
\redm{e_i}{e_i''}
}
{\redm{(\m{SurfHead}~e_1~\ldots~e_i~\ldots~e_n)}{(\m{SurfHead}~e_1~\ldots~e_i''~\ldots~e_n)}}
\infrule[SurfRed2]
{\drule{(\m{SurfHead}~x_1~\ldots~x_i~\ldots~x_n)}{e}\\
\not \exists i.\, \redm{e[e_1/x_1,\ldots,e_i/x_i,\ldots,e_n/x_n]}{e[e_1/x_1,\ldots,e_i'/x_i,\ldots,e_n/x_n]~\&~
\redm{e_i}{e_i''}}
}
{\redm{(\m{SurfHead}~e_1~\ldots~e_i~\ldots~e_n)}{e[e_1/x_1,\ldots,e_i/x_i,\ldots,e_n/x_n]}}
\footnotesize{where~\m{tmpe}~is~any~reduciable~\m{CoreExp}~expression}
\caption{Dynamic Reduction}
\label{fig:dynamic}
\end{figure*}

Putting them in words. For expression \Code{(SurfHead $e_1$ $\ldots$ $e_n$)}, as we discussed in Section \ref{mark:correct}, only reduction on the $e_i$ of the sugar's $LHS$ will not destroy the $RHS$'s form. So we can just take a try after the expansion of \m{SurfHead}. 

For an expression \Code{(CoreHead $e_1$ $\ldots$ $e_n$)}  whose sub-expressions contain \m{SurfExp}, replacing all \m{SurfExp} sub-expressions with any reducible core language's expression $\m{tmpe}_i$ . Then getting a result after inputting the new expression $e'$ to the original black-box stepper. Then two possible cases come.

If reduction appears at a sub-expression at $\m{tmpe}_i$'s location, then the stepper with the extension should return \Code{(CoreHead $e_1$ $\ldots$ $e_i'$ $\ldots$ $e_n$)}, where $e_i'$ is $e_i$ after the mixed language's one-step reduction ($\redm{}{}$) as the following example (rule $\mathtt{CoreExt1}$)
\begin{center}\scriptsize
	\Code{(if (and e1 e2) (or e1 e2) \#f)}\\ $\Downarrow_{replace}$\\ \Code{(if (not \#t) (not \#t) \#f)}\\ $\;\;\Downarrow_{blackbox}$\\ \Code{(if \#f (not \#t) \#f)}\\ $\quad\Downarrow_{reduction}$\\ \Code{(if (if e1 e2 \#f) (or e1 e2) \#f)}
\end{center}

Otherwise (no reduction on $\m{tmp}_i$), the stepper should return \Code{$e'$}, with all the replaced sub-expressions replacing back (rule $\mathtt{CoreExt2}$).
\begin{center}\scriptsize
	\Code{(if \#t (and ...) (or ...))}\\ $\Downarrow_{replace}$ \\\Code{ (if \#t $\m{tmpe}_2$ $\m{tmpe}_3$)}\\ $\;\;\Downarrow_{blackbox}$\\  \Code{$\m{tmpe}_2$}\\ $\quad\;\;\;\Downarrow_{replaceback}$\\ \Code{(and ...)}
\end{center}
We call the extension "one-step-try", because it tries one step on the expression in the black-box stepper. The extension will not violate the properties of the original core language's evaluator. It is obvious that the evaluator with the extension will reduce at the sub-expression as it needs in the core language, if the reduction appears in a sub-expression. The stepper with extension behaves the same as mixing the evaluation rules of the core language and desugaring rules of surface language.

But something goes wrong when substitution takes place during \m{CoreExt2}. For a program like \Code{(let (x 2) (Sugar x y))} as an example, it should reduce to \Code{(Sugar 2 y)} by the \m{CoreRed2} rule, but got \Code{(Sugar x y)} by the \m{CoreExt2} rule. So when using the extension of black-box stepper's rule (\m{ExtRed2}), we need some other information about in which sub-expression a substitution will occur. Then for these sub-expressions, we need to do the same substitution before replacing back. The substitution can be got by a similar idea as the dynamic reduction in our simple core language's setting. For example, we know the third sub-expression of an expression headed with \m{let} is to be substituted. we should first try \Code{(let (x 2) x)}, \Code{(let (x 2) y)} in one-step reduction to get the substitution [2/x], then, getting \Code{(Sugar 2 y)}.

Then for any sugar expression, we can process them dynamically by "one-step-try" like the example in Fig.  \ref{example:try}. (The bold \m{Head} means trying on this expression.)
\example{
\[
{\footnotesize
	\begin{array}{lcl}
	\text{resugaring}&&\text{one-step-try}\\
	\Code{({\bfseries And} (Or \#t \#f)}&\xrightarrow{try}&\Code{(if ({\bfseries Or} \#t \#f)}\\
	\Code{\qquad\hspace{0.5em}(And \#f \#t))}&&\Code{\qquad(And \#f \#t)}\\
	& &\Code{\qquad\#f)}\\
	\qquad\quad\dashdownarrow& &\qquad\qquad\downarrow\\
	\Code{(And ({\bfseries Or} \#t \#f)}& &\Code{(And ({\bfseries if} \#t \#t \#f)}\\
	\Code{\qquad\hspace{0.5em}(And \#f \#t))}&&\Code{\qquad\hspace{0.5em}(And \#f \#t))}\\
	\qquad\quad\dashdownarrow& &\qquad\qquad\downarrow\\
	\Code{({\bfseries And} \#t}&\xrightarrow{try}&\Code{({\bfseries if} \#t}\\
	\Code{\qquad\hspace{0.5em}(And \#f \#t))}&&\Code{\qquad\hspace{0.5em}(And \#f \#t)}\\
	& &\Code{\qquad\hspace{0.5em}\#f)}\\
	\qquad\quad\dashdownarrow& &\qquad\qquad\downarrow\\
	\Code{({\bfseries And} \#f \#t)}&\xrightarrow{try}&\Code{({\bfseries if} \#f \#t \#f)}\\
	\qquad\quad\dashdownarrow& &\\
	\Code{\#f}& &\\
\end{array}
}
\]
}{Example of One-Step-Try}{example:try}

\subsection{\ycomment{Side effect}}


Side effect is a special issue in resugaring. In the previous section, we described the core language as a pure functional language, but some side effects are allowed according to the algorithm. Because the computational order calculated is correct, side effects does not matter if we only consider the evaluation result. But the actual issue is the output of resugaring sequences. Assuming that the core language can process side effects by adding an environment, with a \m{set} expression changing a value of a variable and a \m{begin} expression evaluating all sub-expressions and returning the last result in the core language for using the environment.

If \Code{(begin e ...)} has the context rules
\[
	{\footnotesize
	\begin{array}{lcl}
		\Code{C}&:==&\Code{(\m{begin~C})}\\
		& | &\Code{(\m{begin~C~e~$\ldots$})}\\
		& | &[\bigcdot]
	\end{array}
	}
\]
and reduction rules
\[
{\footnotesize
		\begin{array}{lcl}
		\Code{(begin~$\m{v}_1$~$\m{e}_2$~...)} &\redc{}{}& \Code{(begin~$\m{e}_2$~...)}\\
		\Code{(begin~v)} &\redc{}{}& \Code{v}\\
		\end{array}
}
\]
given a syntactic sugar 
\[\drule{\Code{(inc x y)}}{\Code{(begin (set x (+ x y)) x)}}\]
and for the following expression \Code{(let (x 1) (inc (+ 2 1) x))}, we will have the following evaluation sequence in the core language (omitted the desugaring process).
\begin{center}
	\Code{(let (x 1) (begin (set x (+ (+ 2 1) x) x)))}\\
	$\downarrow$\\
	\Code{(begin (set x (+ (+ 2 1) x) x)) [x:1]}\\
	$\downarrow$\\
	\Code{(begin (set x (+ 3 x) x)) [x:1]} {\footnotesize (inc (+ 2 1) x)}\\

\end{center}
\todo{}



\subsection{Possible Extensions}

So far, our desugaring rules are of a simple form. What if we need a more complex form to describe more complex semantics for syntactic sugar? For example, we may need a type system for checking during desugaring; we may specify the binding of syntactic sugar for more general hygiene; we may use some other functions to help the desugaring. All of these extensions are possible as long as the following conditions are satisfied.
\begin{enumerate}
	\item \emph{Compositional}: Generally speaking, the desugaring order and should not affect the semantics of a sugar expression. Otherwise, the lazy desugaring will not be correct.
	\item \emph{Unique Computational Order}: For any rules of syntactic sugar, the context rules should limit an expression to have only one computational order. Otherwise, the algorithm \m{calcontext} will not be deterministic.
	\item \emph{Clear Semantic}: If a syntactic sugar's desugaring rule is ambiguous or wrong, the algorithm \m{calcontext} may go wrong.
\end{enumerate}

For instance, we may need a desugaring rule like
\[
\drule{\Code{(Sugar $e_1$ $e_2$ $\ldots$ $e_n$)}}{\Code{(if (Helper $e_1$ $e_2$) $\ldots$)}}
\]
where \m{Helper} is an external function, that means we don't have the evaluation rules of \m{Helper}. In this case, we have to force the expansion of sugar expressions headed by \m{Sugar}. We describe how to force the desugaring in Section \ref{mark:simple}.




