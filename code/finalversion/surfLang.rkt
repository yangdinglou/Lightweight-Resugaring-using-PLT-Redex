#lang racket
(require redex)
(require "coreLang.rkt")

(define (CbvHead? exp)
  (member (car exp)
          (list
           'map
           'filter)))

(define (rename exp)
  (define (f s)
    (let ((ss (symbol->string s)))
      (let ((tmp (index-of (string->list ss) #\«)))
        (if tmp
            (string->symbol (substring ss 0 tmp))
            s))))
  (if (pair? exp)
      (map (lambda (x)
             (if (pair? x) (rename x) (if (symbol? x) (f x) x))) exp)
      (f exp))
)

(define (approx-exp? exp1 exp2)
  (if (and (pair? exp1) (pair? exp2))
      (if (and (equal? (length exp1) (length exp2))
               (equal? (car exp1) (car exp2)))
          (if (equal? (foldl + 0
                             (map (lambda (lst1 lst2)
                                    (if (equal? lst1 lst2) 0 1))
                                  exp1 exp2))
                      1)
              (not (or (member exp1 exp2) (member exp2 exp1)))
              #f)
          #f)
      #f))
(define (SurfExp? exp)
  (if (pair? exp)
      (if (redex-match? lang coreexp exp)
          #f
          (andmap SurfExp? exp))
      #t))
(define (func desugar-exp desugar-tried exp);judge if exp with tmpval is the right one.
  (define (eq3 e1 e2 e3) (and (equal? e1 e2) (equal? e2 e3)))
  (if (eq3 (length desugar-exp) (length desugar-tried) (length exp))
      (let ((tmp 0))
        (begin
          (for ((i (length exp)))
            (if (eq3 (list-ref desugar-exp i) (list-ref desugar-tried i) (list-ref exp i))
                (void)
                (if (equal? (list-ref exp i) 'tmpval)
                    (set! tmp (+ tmp 1))
                    (if (and (pair? (list-ref exp i)) (pair? (list-ref desugar-exp i)) (pair? (list-ref desugar-tried i)))
                        (set! tmp (+ tmp (func (list-ref desugar-exp i) (list-ref desugar-tried i) (list-ref exp i))))
                        (set! tmp 2)))))
          tmp))
      2))
(define (get-index desugar-tried desugar-exp exp)
  (let ((idx -1) (ret -1) (possible empty))
    (begin ;(displayln "^&*") (displayln desugar-tried) (displayln desugar-exp) (displayln exp)
      (for ((i (length desugar-exp)))
        (if (equal? (list-ref desugar-exp i) (list-ref desugar-tried i))
            (void)
            (set! idx i)))
      (for ((i (length (cadr exp))))
        (if (and (not (eq? i 0)) (eq? ret -1) (pair? (list-ref (cadr exp) i)))
            (let ((tmpexp (filter (lambda (x) (not (approx-exp? (list-set (cadr exp) i 'tmpval) (cadr x))))
                                  (map rename (remove-duplicates (apply-reduction-relation reductions (list-set exp 1 (list-set (cadr exp) i 'tmpval))))))))
              
              (if (eq? (length tmpexp) 1)
                  (if (equal? 'tmpval (list-ref (cadr (car tmpexp)) idx))
                      (set! ret i)
                      (if (and (not (equal? (list-ref desugar-exp idx) (list-ref (cadr (car tmpexp)) idx)))
                               (eq? 1(func (list-ref desugar-exp idx) (list-ref desugar-tried idx) (list-ref (cadr (car tmpexp)) idx))))
                          (set! ret i)
                          (void))
                      )
                  (begin (displayln tmpexp) (error "1"))))
            (void)))
      ;(display "return") (displayln desugar-tried) (displayln desugar-exp) (displayln exp) (displayln ret)
      ret)))
(define (one-step-try exp)
  (let ((all-possible (map rename (remove-duplicates (apply-reduction-relation reductions exp)))))
    (if (CbvHead? (cadr exp))
        (let ((ret empty) (flg #f))
          (begin
            (for ([i (length (cadr exp))])
              (let ([subexp (list-ref (cadr exp) i)])
                (if (or (not (pair? subexp)) flg)
                    (void)
                    (let ((tmplst (filter (lambda (x)
                                            (and (approx-exp? (cadr x) (cadr exp))
                                                 (not (equal? (list-ref (cadr exp) i) (list-ref (cadr x) i)))))
                                          all-possible)))
                      (if (eq? (length tmplst) 1)
                          (begin (set! ret (car tmplst)) (set! flg #t))
                          (error " in one-step-try"))))))
            ret))
        (let ((idx -1) (ret empty)  [tmpexp (filter (lambda (x) (not (approx-exp? (cadr exp) (cadr x))))
                                                    all-possible)]);desugar-exp
          (begin ;(displayln "!@#") (displayln exp) (displayln all-possible) (displayln "!@#")
            (if (eq? (length tmpexp) 1)
                (let ((desugar-tried (core-algo (car tmpexp))))
                  (if (approx-exp? (cadr desugar-tried) (cadr (car tmpexp)))
                      (let ((tmpidx (get-index (cadr desugar-tried) (cadr (car tmpexp)) exp)))
                        (if (eq? tmpidx -1)
                            (set! ret (car tmpexp))
                            (set! idx tmpidx)))
                      (set! ret (car tmpexp))))
                (begin (displayln tmpexp) (error "at line 80")))
            ;(displayln idx) (displayln (list-set exp 1 (list-ref (cadr exp) idx)))
            (if (not (empty? ret))
                ret
                (let ((retlst (filter (lambda (x)
                               (and (approx-exp? (cadr x) (cadr exp))
                                    (equal? (cadr (core-algo (list-set exp 1 (list-ref (cadr exp) idx)))) (list-ref (cadr x) idx))))
                             all-possible)))
                      (if (> (length retlst) 1)
                          (begin (displayln "///") (displayln exp) (displayln retlst) (displayln idx) (displayln "///")
                                 (car retlst))
                          (car retlst)))

                      ))))))

  
(define (core-algo exp)
  (if (pair? (cadr exp))
      (let ((explst (map rename (remove-duplicates (apply-reduction-relation reductions exp)))))
        (cond
          ((equal? (length explst) 0) (list '(store) empty))
          ((equal? (length explst) 1) (car explst))
          ((or (redex-match? lang commonexp (cadr exp)) (redex-match? lang coreexp (cadr exp)));corner case:(if (and (and ...) (or ...)) ...)
           (let ((tmp (filter (lambda (lst) (not (approx-exp? (cadr exp) (cadr lst))))
                              explst)));maybe have not cover some corner cases
             (if (eq? (length tmp) 1)
                 (car tmp)
                 (let ((idx -1) (ret empty))
                   (begin ;(displayln tmp)
                     (for ((i (length explst)))
                       (for ((j (length (cadr exp))))
                         (if (eq? idx -1)
                             (if (equal? (list-ref (cadr exp) j) (list-ref (cadr (list-ref explst i)) j))
                                 (void)
                                 (set! idx j))
                             (if (equal? (list-ref (cadr exp) j) (list-ref (cadr (list-ref explst i)) j))
                                 (void)
                                 (if (eq? j idx) (void) (error exp))))))
                     (let ((subexp (core-algo (list (car exp) (list-ref (cadr exp) idx)))))
                       (for ((i (length explst)))
                         (if (empty? ret)
                             (if (equal? (cadr subexp) (list-ref (cadr (list-ref explst i)) idx))
                                 (set! ret (list-ref explst i))
                                 (void))
                           (void))))
                     ret)))))
          ((redex-match? lang surfexp (cadr exp))
           (let ((tmp (filter (lambda (lst) (approx-exp? (cadr exp) (cadr lst)))
                              explst)))
             (if (empty? tmp)
                 (begin (displayln explst) (error "error"))
                 ;(cbv-reduce exp tmp)
                 (one-step-try exp)
                 )))))
      (list (car exp) empty)))

#;(core-algo (term ((store)
 (Sg
  (if #t #f #f)
  (not #f)
  #f))))

(define (lightweight-resugaring exp)
  (let ((tmp (core-algo exp)))
    (if (equal? (cadr tmp) empty)
        (displayln "---end---")
        (begin (if (SurfExp? (cadr tmp)) (displayln (cadr tmp)) (void)) #;(displayln tmp) (lightweight-resugaring tmp))
        )))
#;(core-algo (term ((store) (if (and #f (< 1 8)) (cons 1 (filter (λ (x) (and (> x 3) (< x 8))) (list 2 3 4 5 6 7 8 9))) (filter (λ (x) (and (> x 3) (< x 8))) (list 2 3 4 5 6 7 8 9))))))
(lightweight-resugaring (term ((store)
                  (and (and #t #f) (or #f #t))
                  )))
(lightweight-resugaring (term ((store)
                  (Myor (Myor #f #f) (and #t #t))
                  )))
#;(core-algo (term ((store) (Myor (let ((tmp #f)) (if #f #f #f)) (and #t #t)))))
#;(core-algo (term ((store) (let ((tmp (let ((tmp #f)) (if #f #f #f)))) (if (let ((tmp #f)) (if #f #f #f)) (let ((tmp #f)) (if #f #f #f)) (and #t #t))))))
(lightweight-resugaring (term ((store)
                  (Let f (λ (x) (+ 1 x)) (map f (list 1 2 3)))
                  )))
(lightweight-resugaring (term ((store)
                               ((λ (x) (- x 1)) ((λ (x) ((λ (x y) (+ x y)) (+ 1 2) (+ 1 3))) 1))
                               )))

(lightweight-resugaring (term ((store)
                               (Let x (+ 1 2) (+ x (Let x (+ 1 4) (+ x 1))))
                               )))
(lightweight-resugaring (term ((store)
                               (map (λ (x) (+ 1 x)) (list 1 2 3))
                               )))
(lightweight-resugaring (term ((store)
                               (filter (λ (x) (and (> x 3) (< x 6))) (list 1 2 3 4 5 6 7))
                               )))
(lightweight-resugaring (term ((store)
                               (Sg (and #t #f) (not #f) #f)
                               )))

(lightweight-resugaring (term ((store)
                               (Odd 6)
                               )))
(lightweight-resugaring (term ((store)
                               ((S comb) (I comb) ((K comb) xx) yy)
                               )))
