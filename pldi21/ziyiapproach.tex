%!TEX root = ./main.tex

\section{Resugaring by Lazy Desugaring}
\label{sec3}

In this section, we present our new approach to resugaring. Different from the existing approach that clearly separates the surface from the core languages, we intentionally combine them as one mixed language, allowing free use of the language constructs in both languages. We will show that any expression in the mixed language can be evaluated in such a smart way that a sequence of all expressions that are necessary to be resugared by the existing approach can be correctly produced.

\subsection{Mixed Language for Resugaring}

\begin{figure}[t]
\begin{flushleft}
{\footnotesize
\[
\begin{array}{lllll}
 &\m{CoreExp} &::=& x  & \note{variable}\\
       &&~|~& c  & \note{constant}\\
			 &&~|~& (\m{CoreHead}~\m{CoreExp}_1~\ldots~\m{CoreExp}_n) & \note{constructor}\\
\\
 &\m{SurfExp} &::=& x  & \note{variable}\\
       &&~|~& c  & \note{constant}\\
			  % &&~|~& (\m{CoreHead}~\m{SurfExp}_1~\ldots~\m{SurfExp}_n) & \note{selected core constructor}\\
				 &&~|~& (\m{SurfHead}~\m{SurfExp}_1~\ldots~\m{SurfExp}_n) & \note{sugar constructor}\\
\end{array}
\]
}
\end{flushleft}


	\caption{Core and Surface Expressions \todo{}}
	\label{fig:expression}
\end{figure}

As a preparation for our resugaring algorithm, we define a mixed language that combines a core language with a surface language (defined by syntactic sugars over the core language). An expression in this language is reduced step by step by the evaluation rules for the core language and the desugaring rules for the syntactic sugars in the surface language. Our approach assumes the evaluation is {\bfseries compositional} (as the definition in \cite{hygienic}), that is, for evaluation contexts $E_1$ and $E_2$, $E_1[E_2]$ is also a evaluation context.

\subsubsection{Core Language}


For our core language,  its evaluator is driven by \xcomment{Change to: ``The evaluator of our core language is driven by ...'' ?} evaluation rules (context rules and reduction rules), with three natural assumptions. First, the evaluation is deterministic, in the sense that any expression in the core language will be reduced by a unique reduction sequence (restricted by context rules). Second, evaluation of a sub-expression has no side-effect on other parts of the expression. Third, the context rules have no conditions; a counterexample for this assumption is in Fig. \ref{example:side} \xcomment{Change to: ``... have no conditions, which means the rules in Fig. \ref{example:side} is not permitted.'' ?}

\example{\footnotesize
\[
\begin{array}{lll}
\m{C}& ::= & (\m{notif}~[\bigcdot]~e_2~e_3)\\
&|& (\m{notif}~v_1~[\bigcdot]~e_3), (side-condition~(equal?~v_1~\true))\\
&|& (\m{notif}~v_1~e_2~[\bigcdot]), (side-condition~(equal?~v_1~\false))
\end{array}
\]

}{An Example of Context Rules with Conditions}{example:side}


An expression form \xcomment{The term ``expression form'' seems rarely used. An alternative?} of the core language is defined in Fig. \ref{fig:expression}. It is a variable, a constant, or a (language) constructor expression. Here, $\m{CoreHead}$ stands for a language constructor such as $\m{if}$ and $\m{let}$. To be concrete, we will use a simplified core language defined in Fig.  \ref{fig:core} to demonstrate our approach. Here the [e/x] is a capture-avoiding substitution.

\begin{figure*}[thb]
\begin{centering}
\subcaptionbox{Syntax \label{fig:coresyntax}}[0.32\linewidth]{
\[
{\footnotesize
		\begin{array}{lcl}
		\m{CoreExp} &::=& \Code{(CoreExp~CoreExp~...)} ~~\note{// apply}\\
		
		&|& \m{(if~CoreExp~CoreExp~CoreExp)} ~~\note{// condition}\\
		&|& \m{(let~((x~CoreExp)~...)~CoreExp)} ~~\note{// binding}\\
		&|& \m{(listop~CoreExp)} ~~\note{// first, rest, empty?}\\
		&|& \m{(cons~CoreExp~CoreExp)} ~~\note{// data structure of list}\\
		&|& \m{(arithop~CoreExp~CoreExp)} ~~\note{// +, -, *, /, >, <, =}\\
		&|& \m{x} ~~\note{// variable}\\
		&|& \m{value}\\
		\m{value} &::=& \m{($\lambda$~(x~...)~CoreExp)} ~~\note{// call-by-value}\\
		&|& \m{c} ~~\note{// boolean, number and list}
		\end{array}
}
\]
}

\subcaptionbox{Context Rules \label{fig:corecontext}}[0.4\linewidth]{
\[
{\footnotesize
		\begin{array}{lcl}	
		\Code{C} &::=& \Code{(value~...~[$\bigcdot$]~CoreExp~...)}\\
		&|& \Code{(if~[$\bigcdot$]~CoreExp~CoreExp)}\\
		&|& \Code{(let~((x~value)~...~(x~[$\bigcdot$])~(x~CoreExp)~...)~CoreExp)}\\
		&|& \Code{(listop~[$\bigcdot$])}\\
		&|& \Code{(cons~[$\bigcdot$]~CoreExp)}\\
		&|& \Code{(cons~CoreExp~[$\bigcdot$])}\\
		&|& \Code{(arithop~[$\bigcdot$]~CoreExp)}\\
		&|& \Code{(arithop~CoreExp~[$\bigcdot$])}
		\end{array}
}
\]
}

\subcaptionbox{Part of Reduction Rules \label{fig:corereduction}}[0.8\linewidth]{
\[
{\footnotesize
		\begin{array}{lcl}	
		\Code{(($\lambda$~($x_1$~$x_2$~...)~CoreExp)~$\m{value}_1$~$\m{value}_2$~...)} &\redc{}{}& \Code{(($\lambda$~($x_2$~...)~CoreExp[$\m{value}_1$/$x_1$])~$\m{value}_2$~...)}\\

		\Code{(if~$\true$~$\m{CoreExp}_1$~$\m{CoreExp}_2$)}&\redc{}{}& \Code{$\m{CoreExp}_1$}\\
		\Code{(if~$\false$~$\m{CoreExp}_1$~$\m{CoreExp}_2$)}&\redc{}{}& \Code{$\m{CoreExp}_2$}\\
		\Code{(let~(($x_1$~$\m{value}_1$)~($x_2$~$\m{value}_2$)~...)~CoreExp)}&\redc{}{}&\Code{(let~(($x_2$~$\m{value}_2$)~...)~CoreExp[$\m{value}_1$/$x_1$])}\\
		\ldots&&
		\end{array}
}
\]
}



\end{centering}
\caption{A Core Language Example}
\label{fig:core}
\end{figure*}



%For simplicity, we use the prefix notation. For instance, we write $\m{if-then-else}~e_1~e_2~e_3$, which would be more readable if we write $\m{if}~e_1~\m{then}~e_2~\m{else}~e_3$. In this paper, we may write both if it is clear from the context.

\subsubsection{Surface Language}

Our surface language is defined by a set of syntactic sugars, together with some basic elements in the core language, such as constant, variable \xcomment{Change to: ``such as constants and variables'' ?}. The surface language has expressions as given in Fig.  \ref{fig:expression}. \xcomment{Change to: ``Expressions of the surface language is given in Fig. \ref{fig:expression}.'' ?}

Here we just assume a simple rewriting for a syntactic sugar expression. We will show how this approach can be combined with other complex rewriting. A syntactic sugar is defined by a desugaring rule in the following form.

\[
\drule{(\m{SurfHead}~e_1~e_2~\ldots~e_n)}{\m{exp}}
\]
where its left-hand-side (LHS) is a pattern and its left-hand-side (RHS) is an expression of the surface language or the core language. The LHS can be nested or not, that means, we can write sugar \xcomment{Change to: ``sugars''.} like \Code{(SurfHead ($e_1$ ($e_2$ $e_3$)) $\ldots$ $e_n$)}. And any pattern variable (e.g., $e_1$) in LHS only appears once in RHS. For instance, we may define syntactic sugar \m{And} by
\[
\drule{(\m{And}~e_1~e_2)}{(\m{if}~e_1~e_2~\false)}.
\]
And if we need to use a pattern variable multiple times in RHS, a \m{let} binding may be used (a normal way in syntactic sugar). We take the following sugar as an example
\[
\drule{(\m{Twice}~e_1)}{(+~e_1~e_1)}.
\]
If we execute \Code{(Twice (+ 1 1))}, it will firstly \xcomment{Change to: first.} be desugared to \Code{(+ (+ 1 1) (+ 1 1))}, then reduced to \Code{(+ 2 (+ 1 1))} by one step. The subexpression \Code{(+ 1 1)} has been reduced but should not be resugared to the surface, because the other \Code{(+ 1 1)} has not been reduced yet.
So we just use a \m{let} binding to resolve this problem. The RHS should be \Code{(let x $e_1$ (+ x x))} in this case.


Note that in the desugaring rule, we do not restrict the RHS to be a $\m{CoreExp}$. We can use $\m{SurfExp}$ (more precisely, we allow the mixture use of syntactic sugars and core expressions) to define recursive syntactic sugars, as seen in the following example.
\[
\begin{array}{l}
\drule{(\m{Odd}~e)}{(\m{let}~((x~e))~(\m{if}~(>~x~0)~(\m{Even}~(-~x~1))~\false))}\\
\drule{(\m{Even}~e)}{(\m{let}~((x~e))~(\m{if}~(>~x~0)~(\m{Odd}~(-~x~1))~\true))}
\end{array}
\]

As described above, we only assume the desugaring is a textural rewriting, thus there will be many kinds of ill-formed syntactic sugar which cannot desugared well (just as the \m{Odd}, \m{Even} sugars above, although can be processed by our lazy desugaring), or the semantics of the sugar cannot be defined clearly. \todo{maybe an example needed}

We assume that all desugaring rules are not overlapped in the sense that for a syntactic sugar expression, only one desugaring rule is applicable for a single sugar in the expression.


\subsubsection{Mixed Language}
\begin{figure}[t]
\begin{centering}
{\footnotesize
\[
			\begin{array}{lcl}
			\m{Exp} &::=& \m{DisplayableExp}\\
			&|& \m{MixedExp}\\
			\\
			\m{DisplayableExp} &::=& \m{(SurfHead~DisplayableExp*)}\\
			&|& \m{(CommonHead~DisplayableExp*)}\\
			&|& c\\
			&|& x\\
			\\
			\m{MixedExp} &::=& \m{(SurfHead~MixedExp*)}\\
			&|& \m{(CoreHead~MixedExp*)}\\
			&|& c\\
			&|& x\\
			\end{array}
			\]
}

\end{centering}
\caption{Our Mixed Language}
\label{fig:mix}
\end{figure}

Our mixed language for resugaring combines the surface language and the core language, described in Fig.  \ref{fig:mix}.
%
The differences between expressions in our core language and those in our surface language are identified by their \m{Head}. But there may be some expressions in the core language which are also used in the surface language for convenience, or \xcomment{Why using ``or'' here?} we need some core language's expressions to help us getting \xcomment{Change to: get.} better resugaring sequences. So we take \m{CommonHead} as a subset of the \m{CoreHead}, which can be displayed in resugaring sequences. Then if any sub-terms in an expression contain no \m{CoreHead} except for \m{CommonHead}, we should let them display during the evaluation process (named \m{DisplayableExp}). Otherwise, the expression should not be displayable \xcomment{Change to: ``displayed'' ?}. We just use a \m{MixedExp} term to present the expressions which is not necessarily displayed for concision.

 % The \m{SurfExp} denotes an expression that have \m{SurfHead} and their subexpressions being displayable. The \m{CommonExp} denotes an expression with displayable \m{Head} (named \m{CommonHead}) in the core language, together with displayable subexpressions. There exist some other expressions during our resugaring process, which have displayable \m{Head}, but one or more of their subexpressions should not be displayed. They are of \m{UndisplayableExp}. 
We distinguish the displayable expressions for the \emph{abstraction} property (discussed in Section \ref{sec5}).


As an example, for the core language in Fig.  \ref{fig:core},
we may assume \m{arithop}, \m{lambda} (call-by-value lambda calculus), \m{cons} as \m{CommonHead}, \m{if}, \m{let}, \m{lambdaN} (call-by-name lambda calculus), \m{listop} as \m{CoreHead} but out of \m{CommonHead}. This will allow \m{arithop}, \m{lambda} and \m{cons} to appear in the resugaring sequences, and thus display more useful intermediate steps during resugaring.

Note that some expressions with \m{CoreHead} contain subexpressions with \m{SurfHead}, they are of \m{CoreExp} but not in the core language. In the mixed language, we process these expressions by the context rules of the core language, so that the reduction rules of core language and the desugaring rules of surface language can be mixed as a whole (the $\redc{}{}$ in former section). For example, suppose we have the context rule of \m{if} expression\footnote{It is another presentation of \Code{(if $[\bigcdot]$ e e)}, we use this form here for convenience.}
\[
\infer{(\m{if}~e_1~e_2~e_3) \rightarrow (\m{if}~e_1'~e_2~e_3)}{e_1 \rightarrow e_1'}
\]
then if $e_1$ is a reducible expression in the core language, it will be reduced by the reduction rule in the core language: if $e_1$ is a \m{SurfExp}, it will be reduced by the evaluation rule of $e_1$'s \m{Head}; if $e_1$ is also a \m{CoreExp} which has one or more non-core subexpressions, a recursive reduction by $\redc{}{}$ is needed.


\subsection{Resugaring Algorithm}

Our resugaring algorithm works on the mixed language, based on the evaluation rules of the core language and the desugaring rules for defining the surface language. The process for \xcomment{Change to: ``of''.} getting the resugaring sequence contains two separate parts.

\begin{itemize}
\item Calculating the context rules of syntactic sugar.
\item Filtering \m{DisplayableExp} during the execution of the mixed language.
\end{itemize}

We describe the algorithm of calculating the context rules for a syntactic sugar as follows. \xcomment{Change this paragraph to: ``The algorithm for the first part, \texttt{calcontext}, is described as Algorithm \ref{alg:f}. It works as follows.''}

\begin{algorithm}
	\caption{calcontext}
	\label{alg:f}     % 给算法一个标签，以便其它地方引用该算法
	\begin{algorithmic}[1]       % 数字 "1" 表示为算法显示行号的时候，每几行显示一个行号，如："1" 表示每行都显示行号，"2" 表示每两行显示一个行号，也是为了方便其它地方的引用
		\REQUIRE ~~\\      % 算法的输入参数说明部分
		\Code{currentLHS = (SurfHead~$t_1$~$t_2$~$\ldots$~$t_n$)} //where $t_i$ is $e$ or $v$(value).\\
		\Code{currentContext = (Head~$\ldots~e_1'~e_2'~\ldots~e_m'$)} //where $e_i'$ can be at any depth of sub-expressions.\\
		\Code{currentIncal = $\{\ldots\}$} //list of contexts in calculation.
		\ENSURE ~~\\     % 算法的输出说明
		\Code{ListofRule}
		\STATE     \Code{Let ListofRule = \{\}, tmpLHS = currentLHS, InCal = append(currentIncal, SurfHead)}
		\IF {$\not \exists~contexts~rules~of~\m{Head}$}
			\IF {$\exists$ \m{Head} in \m{InCal}}
				\RETURN error
			\ELSE
				\STATE \Code{ListofRule = append(ListofRule,}
				\STATE \qquad\Code{calcontext(\m{Head}.LHS,\m{Head}.RHS,InCal))}
			\ENDIF
		\ENDIF
		\STATE \Code{Let OrderList = $\{e_i',~e_j',~\ldots\}$} //computation order got by context rules
		\FOR {\Code{flag} in \m{OrderList}}
			\IF {$\exists i, s.t. e_i=\Code{flag}$}
				\STATE \Code{ListofRule= append(ListofRule,}
				\STATE \qquad\Code{tmpLHS$[[\bigcdot]/e_i]$)}
			\ELSE
				\STATE \Code{Let recRule, recLHS = calcontext(}
				\STATE \qquad\Code{tmpLHS,~flag,~Incal)}
				\STATE \Code{tmpLHS = recLHS}
				\STATE \Code{ListofRule = append(ListofRule, recRule)}
			\ENDIF
		\ENDFOR
		\RETURN \Code{ListofRule, tmpLHS}
		
	\end{algorithmic}
\end{algorithm}

For sugar 
\[
\drule{(\m{SurfHead}~e_1~e_2~\ldots~e_n)}{(\m{Head}~\ldots~e_1'~e_2'~\ldots~e_m')}
\]
we can just \xcomment{Delete ``just''?} run \Code{calcontext(LHS,~RHS)}, and add the context rules to the mixed language.


If \m{Head} is a \m{CoreHead}, for each context rule of the \m{Head} in order, we should just recursively make context rules for each hole. See example in Fig.  \ref{fig:algoexample1}
\example{
\[
\drule{(\m{Sg1}~e_1~e_2~e_3~e_4)}{(\m{if}~(=~(+~e_4~e_2)~(*~e_1~e_3))~\true~\false)}
\]

$OrderList$ = $\{(=~(+~e_4~e_2)~(*~e_1~e_3))\}$ \hfill(depth1)

$OrderList$ = $\{(+~e_4~e_2),~(*~e_1~e_3)\}$ \hfill(depth2)

$OrderList$ = $\{e_4,~e_2\}$ \hfill(depth3.1, getting rules 

\hfill\{$(\m{Sg1}~e_1~e_2~e_3~[\bigcdot])$, $(\m{Sg1}~e_1~[\bigcdot]~e_3~v_4)$\})

$OrderList$ = $\{e_1,~e_3\}$ \hfill(depth3.2, getting rules 

\hfill\{$(\m{Sg1}~[\bigcdot]~v_2~e_3~v_4)$, $(\m{Sg1}~v_1~v_2~[\bigcdot]~v_4)$\})
}{Example of calcontext}{fig:algoexample1}

Or if the \m{Head} is a \m{SurfHead} with its context rules calculated, then we regard it as \m{CoreHead}. If it is without context rules we should calculate its context rules first. However, if the recursive process has tried calculating it, it will be an ill-formed recursive sugar, as the following example.
\[
\drule{(\m{Odd}~e)}{(\m{Even}~(-~e~1))}
\]

\[
\drule{(\m{Even}~e)}{(\m{Odd}~(-~e~1))}
\]

After calculating all context rules, we can add them to the mixed language's context rule; we can also add the desugaring rules to the mixed language's reduction rule as what we showed in Section \ref{sec2}.

%\todo{Add explanantion of the above rule.}

Now, our resugaring algorithm can be easily defined based on evaluation rules of the mixed language. \xcomment{Remind the reader here comes the second part of the algorithm.} Let $\redm{}{}$ be one step reduction in the mixed language.

\[
\begin{array}{llll}
\m{resugar} (e) &=& \key{if}~\m{isNormal}(e)~\key{then}~return\\
              & & \key{else}~\\
							& & \qquad \key{let}~\redm{e}{e'}~\key{in}\\
							& & \qquad \key{if}~e' \in~\m{DisplayableExp} \\
							& & \qquad \qquad \m{output}(e'),~\m{resugar}(e')\\
							& & \qquad \key{else}~\m{resugar}(e')
\end{array}
\]
During the resugaring, we just apply the reduction ($\redm{}{}$) on the input expression step by step until no reduction can be applied (\m{isNormal}), while outputting those intermediate expressions that belong to \m{DisplayableExp}.


\subsection{Correctness}
\label{mark:correct}

We give following properties to describe the correctness of our resugaring approach.
\begin{Def}[fulldesugar] The function that recursively desugars any expressions of the mixed language is defined as Fig.  \ref{fig:fulldesugar}.\end{Def}

\example{
\begin{flushleft}
\Code{fulldesugar(v) = v}

\Code{fulldesugar(x) = x}

\Code{fulldesugar((CoreHead $e_1$ $e_2$ ...))} =\\\quad\Code{(CoreHead fulldesugar($e_1$) fulldesugar($e_2$) ...)}

\Code{fulldesugar((SurfHead $e_1$ $e_2$ ...))} = \\\quad\Code{(CoreHead fulldesugar($e_1'$) fulldesugar($e_2'$) ...)}\\ \scriptsize{where \Code{desugar((SurfHead $e_1$ $e_2$ ...)) = (CoreHead $e_1'$ $e_2'$ ...)}}
\end{flushleft}

}{Defination of \Code{fulldesugar}}{fig:fulldesugar}
A program \m{P} can be fulldesugared \xcomment{Change to: ``fully desugared'' ?} if \Code{fulldesugar(P)} is terminable.



\begin{mythm} \label{thm1} For a program of the mixed language \m{P} which can be fulldesugared, if a sugar expression \m{S} in the program \m{P} is desugared in one step of the mixed language's evaluation, and program \m{P'} is the \m{P} after \Code{fulldesugar} to the core language, then one step of the core language's evaluation on \m{P'} will destroy the sugar \m{S}'s desugared form.
\end{mythm}

\begin{mythm} \label{thm2} For a program of the mixed language \m{P} which can be fulldesugared, if a core language's expression \m{E} in a program \m{P} of the mixed language is reduced by reduction rules, and program \m{P'} is the \m{P} after \Code{fulldesugar} to the core language, then one step of the core language's evaluation on \m{P'} will reduce on the \m{P'} will also reduce on the correspond expression of \m{E}.
\end{mythm}

The properties limit the laziness of our mixed language---the resugaring sequences should behave as the sequences after desugared to the core language.    

\begin{Def}[Desugaring of context rule]
For syntactic sugar S
\[
\drule{(\m{SurfHead}~e_1~e_2~\ldots~e_n)}{(\m{Head}~\ldots~e_1'~e_2'~\ldots~e_m')}
\]
and context rule \m{C} = $\m{S}.LHS[[\bigcdot]/e_i]$, where $[\bigcdot]$ is at $e_i$'s location. Then $desugar(\m{C})$ = $\m{S}.RHS[[\bigcdot]/e_i]$

\end{Def}

\begin{lemma}
The context rules of syntactic sugar are correct if computable. 

Or to say, for sugar \m{S}, the context rules $C_1$, $C_2$ $\ldots$, if the context rules limit reduction order of $S.LHS$ in $\{e_i,~\ldots,~e_j\}$, then the reduction order of $S.RHS$ is also of this sequence.

\end{lemma}

\begin{proof}
In algo \ref{alg:f}, we recursively search the sugar's RHS to find $e_i$ $\ldots$ in RHS's computation order, so the sugar's context rules are correct.
\end{proof}



\begin{proof}[Proof of Theorem \ref{thm1}]
Consider a context \m{C}, where the sugar \m{S} in the hole. So the P is the program \m{C[S/hole]}. 

If no sugar expression in \m{C}, then it is to prove the program \m{C[fulldesugar(S)/hole]} will reduce on \m{fulldesugar(S)}. It is obvious because that is where the hole at.

If there is any sugar in \m{C}, then it is to prove the program \m{fulldesugar(C[S/hole])} will reduce on \m{fulldesugar(S)}. According to the lemma, it is true because the hole will be at the same place after any sugar recursively desugared.
\end{proof}

\begin{proof}[Proof of Theorem \ref{thm2}]
According to the lemma, any sugar has the correct context rules. So the hole is also correct for the mixed language.
\end{proof}

\subsection{Combining with Other Rewriting}

We describe a resugaring approach based on a simple rewriting. What if we need a more complex rewriting system to describe more complex semantics for syntactic sugar? For example, we may need a type system for checking; we may specify the binding of syntactic sugar for a more general hygiene (We solved the hygiene in our core language without specific the binding, as described in Section \ref{mark:hygiene}); we may use some other functions to help the desugaring. All of these extensions are possible as long as following some conditions. We summarize the conditions as follows.
\begin{enumerate}
	\item \emph{Compositional}: Generally speaking, the desugaring order and should not effect the semantics of a sugar expression. Otherwise, the lazy desugaring will not be correct.
	\item \emph{Unique evaluation order}: For any rules of syntactic sugar, the context rules should limit a expression to have only one computational order. Otherwise the algorithm calcontext will not be deterministic.
	\item \emph{Clear Semantic}: If a syntactic sugar's desugaring rule is ambiguous or wrong, the calcontext algorithm may go wrong.
\end{enumerate}

We find a possible problem that if we want a desugar rule like follows,

\[
\drule{\Code{(Sugar $e_1$ $e_2$ $\ldots$ $e_n$)}}{\Code{(if (Helper $e_1$ $e_2$) $\ldots$)}}
\]
where \m{Helper} is a external function, that means we don't have the evaluation rules of \m{Helper}. In this case, we can force the expansion of sugar expressions headed by \m{Sugar}. We describe how to force the expansion in Section \ref{mark:simple}.