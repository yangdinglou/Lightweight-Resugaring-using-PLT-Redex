%!TEX root = ./main.tex
\section{Introduction}

%What is the research background and and what motivate you to do this research?

%What is the research issue and how the issue has been addressed so far?

%What is the remained research problem and how challenge it is?

%What is your key idea (insight) of your solution to be discussed in this paper?

%What are the three main technical contributions of this paper?

%The rest of the paper is organized as follows. ...



Syntactic sugar, first coined by Peter J. Landin in 1964 \cite{syntacticsugar}, was introduced to describe the surface syntax of a simple ALGOL-like programming language which was defined semantically in terms of the applicative expressions of the core lambda calculus. It has been proved to be very useful for defining domain-specific languages (DSLs) and extending languages \cite{FellFFKBMT18,CulpFFK19}.
Unfortunately, when syntactic sugar is eliminated by transformation, it obscures the relationship between the userâ€™s source program and the transformed program.



Resugaring is a powerful technique to resolve this problem \cite{resugaring,hygienic}. It  can automatically convert the evaluation sequences of desugared program in the core language into representative sugar's syntax in the surface language. Just like the existing approach, it is natural to try matching the programs after the desugared with syntactic sugars' rules to reversely desugar the sugars---that why it was named "resugaring". Here we use the sugar \Code{Newor} to see how existing resugaring approach works, with following desugaring rule. (Considering the \m{not} as a core language's constructor)

\begin{center}
	\[
	{\footnotesize
		\begin{array}{lcl}
		Surface&&Core\\
		\Code{(Newor (not \#t) }&\xrightarrow{desugar}&\Code{(let ((t (not \#t))) }\\
		\Code{\qquad \#t)}&\xleftarrow{resugar}&\Code{\qquad\hspace{0.5em}(if t t \#t))}\\
		\qquad\quad\dashdownarrow& &\qquad\qquad\downarrow\\
		\Code{(Newor \#f }& &\Code{(let ((t \#f)) }\\
		\Code{\qquad \#t)}&\xleftarrow[resugar]&\Code{\qquad\hspace{0.5em}(if t t \#t))}\\
		\qquad\quad\dashdownarrow& &\qquad\qquad\downarrow\\
		\text{no resugaring}& &\Code{(if \#f \#f \#t)}\\
		\qquad\quad\dashdownarrow& &\qquad\qquad\downarrow\\
		\Code{\#t}& & \Code{\#t}\\
	\end{array}
	}
	\]
	{\scriptsize where $\drule{\Code{(Newor $e_1$ $e_2$)}}{\Code{(let ((t $e_1$)) (if t t $e_2$))}}$}
\end{center}


But it is not as easy as the example above. Sometimes the program in the core language contains a desugared form of a sugar, but the form may belong to original (not desugared) program. In the following example, the reverse expansion of sugar should be noticed.
\begin{center}
\[
{\footnotesize
	\begin{array}{lcl}
	Surface&&Core\\
	\Code{(let ((t \#t)))}&\xrightarrow{desugar}&\Code{(let ((t \#t)))}\\
	\Code{\quad(if t t (Newor \#t \#f)))}&\xleftarrow[resugar]&\Code{\quad(if t t (let\ldots))}\\
	\qquad\qquad\dashdownarrow& &\qquad\qquad\downarrow\\
	\qquad\qquad\vdots& &\qquad\qquad\vdots\\
	\qquad\qquad\dashdownarrow& &\qquad\qquad\downarrow\\
	\Code{(Newor \#t \#t)}& &\Code{(let ((t \#t))}\\
	&\xleftarrow[resugar?]&\Code{\quad(if t t \#t))}\\
	\qquad\qquad\vdots& &\qquad\qquad\vdots\\
\end{array}
}
\]
{\scriptsize where $\drule{\Code{(Newor $e_1$ $e_2$)}}{\Code{(let ((t $e_1$)) (if t t $e_2$))}}$}
\end{center}


Moreover, when meeting hygienic sugar, the simple match and substitution will not work as following example shows. 

\[
{\footnotesize
	\begin{array}{lcl}
	Surface&&Core\\
	\Code{(let (t 1)}&\xrightarrow{desugar}&\Code{(let (t 1)}\\
	\Code{\quad(Double t))}&\xdashleftarrow[resugar?]&\Code{\quad(let (t' t) (* 2 t')))}\\
	\qquad\qquad\dashdownarrow& &\qquad\qquad\downarrow\\
	\Code{\quad(Double 1))}&\xdashleftarrow[resugar?]&\Code{\quad(let (t' 1) (* 2 t')))}\\
\end{array}
}
\]
{\scriptsize where $\drule{\Code{(Double $e_1$)}}{\Code{(let (t $e_1$) (+ t t))}}$}

If we use binder renaming for solving the simple case, some other information is needed (such as the permutation $\m{t} \to \m{t'}$).



% \todo{Examples of 2 resugaring method(what is, why hard)}

The existing resugaring approaches subtly solved the problems above by "tagging"\cite{resugaring} and "abstract syntax DAG"\cite{hygienic}. While those techniques successfully make the resugaring method usable, there is a key point which makes the existing approaches not very practical---the reverse expansion of sugars need to match the desugared programs to see if it is able to resugar. It is quite a huge job when the program contains many syntactic sugars or some syntactic sugars can be desugared to large sub-expressions.
Also, as the debugging for surface languages can be a good application of resugaring, the efficiency matters.


% \todo{why existing resugaring has a problem, examples. good but complicate, novel without desugaring}

\label{mark:mention}
In this paper, we propose a novel approach to compositional resugaring, which does not use reverse desugaring at all.
The key idea is "lazy desugaring", in the sense that desugaring is delayed so that the reverse application of desugaring rules becomes unnecessary. Rather than assuming a black-box stepper for the core language as the existing approach, our resugaring approach is based on the evaluation rules (consist of the context rules and reduction rules) of the core language. So our approach seems to be a meta-level language feature rather than a tool for existing languages. (Although it can also work with a black-box stepper, as we will discuss in Section \ref{sec5.1})
To this end, we consider the surface language and the core language as a whole language. We regard the desugaring rules as the reduction rules of surface language and calculate the context rules of surface language to see how lazy the desugaring of sugar expressions can be. Then the intermediate evaluation steps of the mixed language will contain the resugaring evaluation sequences of a program.


Our main technical contributions can be summarized as follows.
\begin{itemize}
\item We propose a novel approach to resugaring by lazy desugaring, where reverse application of desugaring rules becomes unnecessary. We recognize a algorithm to calculate the computational orders (limited by context rules) for syntactic sugars, and propose a reduction strategy, based on evaluator of the core languages and the desugaring rules together with the context rules of syntactic sugar, which is sufficient to produce all necessary resugared expressions on the surface language. We prove the correctness of our approach.

\item We have implemented a system based on the new resugaring approach. It is much more efficient than the existing approach, because it completely avoids unnecessary complexity of the reverse desugaring. It also provides extra expressiveness for even the simple rewriting so that it can also deal with the common hygienic sugars and flexible recursive sugars. All the examples in this paper have passed the test of the system. 

\item We discuss how lazy desugaring makes sense, including how the approach can be extended to a model with black-box stepper, how it can easily deal with hygiene, and how we deal with the trade-off of correctness.


\end{itemize}

The rest of our paper is organized as follows. We start with an overview of our approach in Section \ref{sec2}. We then discuss the core of resugaring by lazy desugaring in Section \ref{sec3}. We describe our experiment and evaluation in Section \ref{sec4}. We discuss  some other issues in Section \ref{sec5}, on related work in Section \ref{sec6}, and conclude the paper in Section \ref{sec7}.
