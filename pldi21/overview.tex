%!TEX root = ./main.tex
\section{Overview}
\label{sec2}


In this section, we give a brief overview of our approach. To be concrete, we will consider the following simple core language, defining boolean expressions together with \m{if} construct:
\[
\begin{array}{lllll}
e &::=& \m{CoreExp}\\
\m{CoreExp} &::=& \Code{(if~$e$~$e$~$e$)} &\note{// if construct}\\
& |& \true  & \note{// true value}\\
& |& \false & \note{// false value}
\end{array}
\]
The semantics of the language is very simple, consisting of the following context rule defining the computational order:

\[
\begin{array}{lcl}
C &:=& \Code{(if $[\bigcdot]$ $e$ $e$)}\\
&|&hole\\
\end{array}
\]
and two reduction rules (the letter c means core):
\[
\centering
 \redc{(\m{if}~\true~e_1~e_2)}{e_1}  \qquad \redc{(\m{if}~\false~e_1~e_2)}{e_2} 
\]
Assume that our surface language is defined by two syntactic sugars defined by:
%---\emph{and} sugar and \emph{or} sugar on the core language.
\[
\begin{array}{c}
\drule{(\m{And}~e_1~e_2)}{(\m{if}~e_1~e_2~\false)}\\
\drule{(\m{Or}~e_1~e_2)}{(\m{if}~e_1~\true~e_2)}
\end{array}
\]


Now let us demonstrate how to execute \Code{(And (Or \true~\false) (And \false ~\true))}, and get the resugaring sequences as follows by our approach.

{\scriptsize
\begin{Codes}
    (And (Or \true \false) (And \false \true))
\OneStep{ (And \true (And \false \true))}
\OneStep{ (And \false \true)}
\OneStep{ #f}
\end{Codes}
}


We propose a new resugaring approach by eliminating "reverse desugaring" via "lazy desugaring", where a syntactic sugar will be expanded only when it is necessary. While giving the evaluation rules of the core language, we can figure out the following context rules of the surface language. From the context rules of \m{if}, we can find that the condition ($e_1$) is always evaluated first. Therefore, for expression \Code{And $e_1$ $e_2$} defined by syntactic sugar, $e_1$ is also evaluated first, which is the context rule of \m{And}. Similarly, we can calculate the context rule of \m{Or}.

\[
\begin{array}{lcl}
C &:=& (\m{And}~[\bigcdot]~e)\\
&|& (\m{Or}~[\bigcdot]~e)\\
&|&hole\\
\end{array}
\]

Then we mix the surface language and the core language as Fig. \ref{fig:mixexample}, where \m{CommonExp} means the expressions used in the surface language and the core language both, and $\to_m$ is a one-step evaluation in our mixed language.

\begin{figure}[thb]
\centering
\subcaptionbox{Syntax \label{fig:mixsyntax}}[\linewidth]{\footnotesize
\begin{flushleft}
\[
\begin{array}{lll}
e &::=& \m{CoreExp} \\
&|&\m{SurfExp}\\
&|&\m{CommonExp}\\
\m{CoreExp} &::=& \Code{(if~$e$~$e$~$e$)}\\
\m{SurfExp} &::=& \Code{(And~$e$~$e$)}\\
&|&\Code{(Or~$e$~$e$)}\\
\m{CommonExp} &::=& \true\\
&|& \false\\
\end{array}
\]
\end{flushleft}

}
\subcaptionbox{Context Rules \label{fig:mixcontext}}[\linewidth]{
\begin{flushleft}
\[\footnotesize
\begin{array}{lcl}
C &:=& (\m{if}~[\bigcdot]~$e$~$e$)\\
&|& (\m{And}~[\bigcdot]~$e$)\\
&|& (\m{Or}~[\bigcdot]~$e$)\\
&|&hole\\
\end{array}
\]
\end{flushleft}

}

\subcaptionbox{Reduction Rules \label{fig:mixreduction}}[\linewidth]{\footnotesize
\begin{flushleft}
\[
\begin{array}{c}
\redm{(\m{And}~e_1~e_2)}{(\m{if}~e_1~e_2~\false)}\\
\redm{(\m{Or}~e_1~e_2)}{(\m{if}~e_1~\true~e_2)}\\
\redm{(\m{if}~\true~e_1~e_2)}{e_1}\\
\redm{(\m{if}~\false~e_1~e_2)}{e_2} 
\end{array}
\]
\end{flushleft}

}

\caption{Mixed Language Example}
\label{fig:mixexample}
\end{figure}

Finally the program \Code{(And (Or \true~\false) (And \false~\true))} will get the evaluation sequence as follows in the mixed language. We can just filter the intermediate sequences without \m{Coreexp} in any sub-expressions to get the resugaring sequence above.

{\scriptsize
\begin{Codes}
    (And (Or \true \false) (And \false \true))
\OneStep{ (And (if \true \true \false) (And \false \true))}
\OneStep{ (And \true (And \false \true))}
\OneStep{ (if \true (And \false \true) \false)}
\OneStep{ (And \false \true)}
\OneStep{ (if \false \true \false)}
\OneStep{ \false}
\end{Codes}
}
Note that the context rules should restrict the computational order of a sugar expression's sub-expressions, thus we should let the context rules be correct---reflecting what should be executed in the desugared expression. Also, as the goal of resugaring is to present the evaluation of sugar programs, we clearly defined which expression should be outputted. For the example in this section, of course, the sugar \m{And} and \m{Or} should be outputted, and also the boolean expressions should be. So we set boolean expressions as \m{CommonExp}, so that they can be displayed though they are of the core language. By clearly separating what should be displayed, we can always get the resugaring evaluation sequences we need. (Slightly different from the existing approach's setting, as we will discuss in Section \ref{mark:correct}.)