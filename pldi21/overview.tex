%!TEX root = ./main.tex
\section{Overview}
\label{sec2}


In this section, we give a brief overview of our approach, explaining its difference from the existing  approach and highlighting its new features. To be concrete, we will consider the following simple core language, defining boolean expressions based on \m{if} construct:
\[
\begin{array}{lllll}
e &::=& \m{CoreExp}\\
\m{CoreExp} &::=& \Code{(if~$e$~$e$~$e$)} &\note{// if construct}\\
& |& \true  & \note{// true value}\\
& |& \false & \note{// false value}
\end{array}
\]
The semantics of the language is very simple, consisting of the following context rule defining the computational order:

\[
\begin{array}{lcl}
C &:=& \Code{(if $[\bigcdot]$ $e$ $e$)}\\
&&hole\\
\end{array}
\]
and two reduction rules (the letter c means core):
\[
\centering
 \redc{(\m{if}~\true~e_1~e_2)}{e_1}  \qquad \redc{(\m{if}~\false~e_1~e_2)}{e_2} 
\]
Assume that our surface language is defined by two syntactic sugars defined by:
%---\emph{and} sugar and \emph{or} sugar on the core language.
\[
\begin{array}{c}
\drule{(\m{And}~e_1~e_2)}{(\m{if}~e_1~e_2~\false)}\\
\drule{(\m{Or}~e_1~e_2)}{(\m{if}~e_1~\true~e_2)}
\end{array}
\]


Now let us demonstrate how to execute \Code{(And (Or \true~\false) (And \false ~\true))}, and get the resugaring sequences as Fig.  \ref{fig:standard} by our approach.

\begin{figure}[thb]
\begin{center}
\begin{minipage}{6cm}
\begin{footnotesize}
\begin{Codes}
    (And (Or \true \false) (And \false \true))
\OneStep{ (And \true (And \false \true))}
\OneStep{ (And \false \true)}
\OneStep{ #f}
\end{Codes}
\end{footnotesize}
\end{minipage}
\end{center}
\caption{A Typical Resugaring Example}
\label{fig:standard}
\end{figure}


We propose a new resugaring approach by eliminating "reverse desugaring" via "lazy desugaring", where a syntactic sugar will be desugared only when it is necessary. While giving the evaluation rules of the core language, we can figure out the following context rules of the surface language.\gcomment{From the context rules of \m{if}, we can find that the condition ($e_1$) is always evaluated first. Therefore, for expression $e_1~\m{And}
~e_2$ defined by syntactic sugar, $e_1$ is also evaluated first, which is the context rule of \m{And}. Similarly, we can calculate the context rule of \m{Or}.}

\[
\begin{array}{lcl}
C &:=& (\m{And}~[\bigcdot]~e)\\
&|& (\m{Or}~[\bigcdot]~e)\\
&|&hole\\
\end{array}
\]

Then we can just mix the surface language and the core language as Fig. \ref{fig:mixexample}. \gcomment{Then we mix the surface language and the core language as Fig. \ref{fig:mixexample}, where \m{CommonExp} means the expressions used in the surface language and the core language both, and $\to_d$ is a one-step evaluation in our mixed language.}

\begin{figure}[thb]
\centering
\subcaptionbox{Syntax \label{fig:mixsyntax}}[\linewidth]{\footnotesize
\begin{flushleft}
\[
\begin{array}{lll}
e &::=& \m{CoreExp} \\
&|&\m{SurfExp}\\
&|&\m{CommonExp}\\
\m{CoreExp} &::=& \Code{(if~$e$~$e$~$e$)}\\
\m{SurfExp} &::=& \Code{(And~$e$~$e$)}\\
&|&\Code{(Or~$e$~$e$)}\\
\m{CommonExp} &::=& \true\\
&|& \false\\
\end{array}
\]
\end{flushleft}

}
\subcaptionbox{Context \label{fig:mixcontext}}[\linewidth]{
\begin{flushleft}
\[\footnotesize
\begin{array}{lcl}
C &:=& (\m{if}~[\bigcdot]~$e$~$e$)\\
&|& (\m{And}~[\bigcdot]~$e$)\\
&|& (\m{Or}~[\bigcdot]~$e$)\\
&|&hole\\
\end{array}
\]
\end{flushleft}

}

\subcaptionbox{Reduction \label{fig:mixreduction}}[\linewidth]{\footnotesize
\begin{flushleft}
\[
\begin{array}{c}
\redm{(\m{And}~e_1~e_2)}{(\m{if}~e_1~e_2~\false)}\\
\redm{(\m{Or}~e_1~e_2)}{(\m{if}~e_1~\true~e_2)}\\
\redm{(\m{if}~\true~e_1~e_2)}{e_1}\\
\redm{(\m{if}~\false~e_1~e_2)}{e_2} 
\end{array}
\]
\end{flushleft}

}

\caption{Mixed Language Example}
\label{fig:mixexample}
\end{figure}

Finally the program\gcomment{expression} \Code{(And (Or \true~\false) (And \false~\true))} will got\gcomment{get} the evaluation sequence in Fig.  \ref{fig:mixexec} in the mixed language. We can just filter the intermediate sequences without \m{Coreexp} in any sub-expressions to get the resugaring sequence as Fig.  \ref{fig:standard}.

\begin{figure}[thb]
\begin{center}
\begin{footnotesize}
\begin{Codes}
    (And (Or \true \false) (And \false \true))
\OneStep{ (And (if \true \true \false) (And \false \true))}
\OneStep{ (And \true (And \false \true))}
\OneStep{ (if \true (And \false \true) \false)}
\OneStep{ (And \false \true)}
\OneStep{ (if \false \true \false)}
\OneStep{ \false}
\end{Codes}
\end{footnotesize}
\end{center}
\caption{Example of Mixed Language's Reduction}
\label{fig:mixexec}
\end{figure}

Note that the context rules should restrict the computational order of a sugar expression's sub-term, we should let the context rules be correct---reflecting what should be executed in the desugared expression. Also, as the goal of resugaring is to present evaluation of sugar expressions, we clearly defined which expression should be outputted. For the example in this section, of course the sugar \m{And} and \m{Or} should be outputted, and also the boolean expressions should be. So by clearly separate what \m{DisplayableExp} (defined in next section) is, we can alway get the resugaring evaluation sequences we need. (Slightly different from the existing approach's setting, as we will discuss in Section \ref{mark:correct}.)