%!TEX root = ./main.tex
\section{Related Work}
\label{sec5}
%Explain the work that are related to your problem, and to your three contributions. 

\emph{Resugaring sequences }\cite{resugaring,hygienic} As we have discussed many times, the concept of resugaring is original from their work, by the main idea of "tagging" and "reverse desugaring". Our approach is more lightweight, powerful and efficient, as discussed before. In summary, we also find some common issues about resugaring.
\begin{itemize}
\item Side effects in resugaring.\label{mark:side} In the first paper of resugaring, they try a \m{letrec} sugar based on \m{set!} term in core language and get no intermediate steps. After trying some syntactic sugars that contain side effects, we would say a syntactic sugar including side-effect is bad for resugaring, because after a side effect takes effect, the desugared expression should never resugar to the sugar expression. Thus, we don't think resugaring is useful for syntactic sugars  including side effects, though it can be done by marking any expressions which have a side effect.
\item Hygienic resugaring. As we showed in both the basic approach and the automatic derivation, hygiene is easily and naturally resolved by lazy desugaring, because it may behave as what the sugar ought to express. The second paper of resugaring presents a DAG to solve the problem, which is a smart but not concise way.
\item Assumption on core language. The traditional resugaring and the dynamic approach both use a blackbox evaluator of core language, while the dynamic approach use the semantics of core language. We found that if given the semantics of core language, the resugaring will be more convenient. The blackbox evaluator in our dynamic approach will not need the extension, while the rules getting by our static approach is more express. 
\end{itemize}

\emph{Type resugaring} \cite{resugaringtype} is a later work of sequence resugaring. It automatically derivation type rules of syntactic sugar by unification. It indicates that it is possible to automatically construct surface language's semantics by unification. But after trying to do this as type resugaring does, we found it hard because the method may assume only one rule for multi-branches of one syntactic sugar, which is not suitable for evaluation rules. We also find getting evaluation rules in big-step semantics is easier, but not works well for syntactic sugar. \emph{Pretty-Big-Step Semantics} \cite{pretty} is an improved version of big-step semantics, which may be useful to achieve more powerful automatic derivation of evaluation rules.




\emph{Macros as Multi-Stage Computations} \cite{multistage} is a work similar to lazy expansion for macros. Some other researches\cite{modularstaging} about multi-stage programming\cite{MSP} indicate that it is an useful idea for implementing domain-specific languages. Overall, multi-stage programming is a metaprogramming method based on run-time code generation. In contrast, our resugaring approach gives abstraction by carefully design the reduction of mixed language. Moreover, the lazy desugaring gives us chance to derive evaluation rules of sugars, which is a new good point compared to multi-stage programming.

\emph{Galois slicing for Imperative Functional Programs} \cite{slicing} is a work for dynamic analyzing functional programs during execution. The forward component of the Galois connection maps a partial input x to the greatest partial output y that can be computed from x; the backward component of the Galois connection maps a partial output y to the least partial input x from which we can compute y. Our approach used a similar idea on slicing expressions and processing on subexpressions. It's just like bidirectional transformation \cite{bx} and the round-tripping between desugaring and resugaring in existing approach. In contrast, our resugaring approach is unidirectional, by an attempt on expanding sugar, just like the forward component of Galois connection. It should be noted that Galois slicing may be useful to handle side effects in resugaring (for example, slicing the part where side effects appear).

\emph{Origin tracking}\cite{origintracking} is about tracking the origins of terms in rewriting system, which does not involve the use of syntactic sugar. The key idea \emph{lazy desugaring} makes our approach easy to solve the problems introduced by syntactic sugar. And the tracking in their notation can be easily done for sugar whose rules can be derived automatically.

Since the existing resugaring approach firstly desugars all sugar in programs, it is more similar to debugging process, where as our approach is likely engineering the semantics of language. \emph{Ziggurat} \cite{Ziggurat} is a semantic-extension framework. It allows defining new macros with semantics based on existing terms in a language. It is quite useful for static analysis on macros. Instead of semantics based on core language, the reduction rules of sugar derived by our approach is independent of core language, which may be more concise for static analysis. Addition to PLT Redex\cite{SEwPR} which we used to engineer the semantics, there are some other semantics engineering tools \cite{dynsem,Ksemantic} which aim to test or verify the semantics of languages. The methods of these researches can be easily combined with our approach to implement more general rule derivation.
