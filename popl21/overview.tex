%!TEX root = ./main.tex
\section{Overview}
\label{sec2}

Use a simple but sharp example to give an overview of your approach.

The key idea of our lightweight resugaring approach, is that, we won't expand a syntactic sugar until we must desugar it. We design a core algorithm to choose the right reduction rule for any expression during the execution. Take the example $\mbox{and}(\mbox{or}(\#f, \#t), \mbox{and}(\#t, \#f))$ again. We will get the sequence as ...

\begin{figure}[ht]
\parbox[t]{\textwidth}{
			\begin{center}  
				(and (or \#f \#t) (and \#t \#f))\\
				~~~~~↓step1\\
				(and (if \#f \#t \#t) (and \#t \#f))\\
				~~~~~↓step2\\
				(and \#t (and \#t \#f))\\
				~~~~~↓step3\\
				(if \#t (and \#t \#f) \#f)\\
				~~~~~↓step4\\
				(and \#t \#f)\\
				~~~~~↓step5\\
				(if \#t \#f \#f)\\
				~~~~~↓step6\\
				\#f
			\end{center}  
		}
\caption{core-algo example}
\label{fig:core-algo}
\end{figure}

At step 1, we found the outermost $and$ sugar don't have to expand, because its first sub-expression will reduce earlier. At step 2, the same as step 1. At step 3, the outermost $and$ sugar have to expand, because no sub-expression will reduce after the whole expression desugar. At step 4, the inner $and$ sugar don't have to expand either. At step 5, the sugar have to desugar to CoreLang. Finally at step 6, er get the final result.