%!TEX root = ./main.tex
\section{Introduction}

%What is the research background and and what motivate you to do this research?

%What is the research issue and how the issue has been addressed so far?

%What is the remained research problem and how challenge it is?

%What is your key idea (insight) of your solution to be discussed in this paper?

%What are the three main technical contributions of this paper?

%The rest of the paper is organized as follows. ...

%Domain-specific languages \cite{dsl} are becoming more and more important in our daily lives; the IFTTT apps and IOS's shortcuts use many DSLs to describing various  tasks to make our lives more convenient.
%The users of DSL are no longer limited to programmers, but people from all walks of life.(to be completed)

Syntactic sugar, first coined by Peter J. Landin in 1964 \cite{syntacticsugar}, was introduced to describe the surface syntax of a simple ALGOL-like programming language which was defined semantically in terms of the applicative expressions of the core lambda calculus. It has proved to be very useful for defining domain specific languages (DSLs) and extending languages \cite{FellFFKBMT18,CulpFFK19}.
Unfortunately, when syntactic sugar is eliminated by transformation, it obscures the relationship between the userâ€™s source program and the transformed program.

%
% has an obvious problem. DSL based on syntactic sugars contains many components of its host language. Then its interpretation will be outside the DSL itself. The evaluation sequences of syntactic sugar expressions will contain many terms of the host language, which may confuse the users of DSL.

Resugaring is a powerful technique to resolve this problem \cite{resugaring,hygienic}. It  can automatically convert the evaluation sequences of desugared expression in the core language into representative sugar's syntax in the surface language.
As demonstrated in Section \ref{sec2},
%to guarantee the properties of emulation, %(preserving correctness in semantics),
%abstraction,
%(keeping abstraction of syntax sugar),
%and coverage,
% (doing conversion as much as possible),
the key idea in this resugaring is "tagging" and "reverse desugaring": it tags each desugared core term with the corresponding desugared rule, and follows the evaluation steps in the core language but keep applying the desugaring rules reversibly as much as possible to find surface-level representations of the tagged core terms.

While it is natural to do resugaring by reverse desugaring of tagged core terms, it introduces complexity and inefficiency.
\begin{itemize}
\item {\em Tricky to handle recursive sugar}. While tagging is used to remember the position of desugaring so that reverse desugaring can be done at correct position when desugared core expression is evaluated, it  becomes very tricky and complex when recursive sugars are considered. Moreover, it can only handle the recursive sugar which can be written by pattern-based desugaring rules \cite{resugaring}.%\todo{pattern-based?}

\item {\em Complicated to handle hygienic sugar}. For reverse desugaring, we need to match part of the core expression on the RHS of the desugar rule and to get the surface term by substitution. But when a syntactic sugar introduce variable bindings, this match-and-substitute turns out to be very complex if we consider local bindings (hygienic sugars) \cite{hygienic}.

\item {\em Inefficient in reverse desugaring.} It need to keep checking whether reverse desugaring is applicable during evaluation of desugared expression, which is very costive. Moreover, the match-and-substitute for reverse desugaring is costive particularly when the core term is big.

\end{itemize}

In this paper, we propose a novel approach to resugaring, which does not use tagging and reverse desugaring at all.
The key idea is "lazy desugaring", in the sense that desugaring is delayed so that the reverse application of desugaring rules become unnecessary.
%of the whole approach is---syntactic sugar expressions only desugar at the point they have to desugar, which is what the word "lazy" means. It would be correct for resugaring if we can prove the whole sugar expressions will keep the properties by such lazy processes.
We consider the surface language and the core language as one language, and reduce expressions dynamically either by the reduction rules in the core language or by the desugaring rules for defining syntactic sugars. To gain more efficiency, we can make a shortcut of a sequence of core expression reduction to a one-step reduction of the surface language, by automatically deriving evaluation rules on the surface language from those on the core language.


Our main technical contributions can be summarized as follow. \todo{The following contributions will be revised later.}
\begin{itemize}
\item {\em A lightweight, efficient and powerful resugaring approach by lazy desugaring.} The resugaring approach we proposed is based on reductions of a mixed language. It takes surface language and core language as a whole, then decided whether desugaring the sugars or reducing the subexpressions according to properties that make the resugaring correct. Thus, it is lightweight because many match and substitution processes can be omitted. We test the  approach on many applications. The result shows that in addition to handle what existing work can handle, our dynamic approach can process non-pattern-based recursive sugar and hygienic sugar easily, which makes it powerful. And the rewriting system based on reduction semantics makes it possible to write syntactic sugar easily.
\item {\em Automatic derivation of syntactic sugar's evaluation rule.} We abstract our resugaring approach to a derivation of syntactic sugar's evaluation rule. The derivation turns core language's evaluation rules into \emph{Inference automaton} (\todo{see ...}) . And for each syntactic sugar, we would generate the surface language's evaluation rules without depending on some rules in core language. (some meta-functions may be necessary.)  The the resugaring sequences can be easily got from the evaluation rules. Since the derivation can work together with the basic resugaring, our resugaring approach becomes more efficient because many steps in core language can be omitted.
\item {\em Correctness}.
\end{itemize}

We have implemented lazy desugaring and automatic derivation of reduction rules for syntactic sugars. All the example in this paper have passed the test of the system.

The rest of our paper is organized as follow. We start with an overview of our approach in Section \ref{sec2}. We then discuss the core of resugaring by lazy desugaring in Section \ref{sec3}, and automatic derivation of reduction rules for syntactic sugars in Section \ref{sec4}. We discuss relative work in Section \ref{sec5}, and conclude the paper in Section \ref{sec6}.
