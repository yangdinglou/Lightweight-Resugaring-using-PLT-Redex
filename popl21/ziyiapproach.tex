%!TEX root = ./main.tex

\section{Resugaring by Lazy Desugaring}
\label{sec3}

In this section, we present our new approach to resugaring. Different from the traditional approach that clearly separates the surface from the core languages, we intentionally combine them as one mixed language, allowing free use of the language constructs in both languages. We will show that any expression in the mixed language can be evaluated in such a smart way that a sequence of all expressions that are necessary to be resugared by the traditional approach can be correctly produced.

\subsection{Mixed Language for Resugaring}

\begin{figure}[t]
{\footnotesize
\[
	\begin{array}{lllll}
	 &\m{CoreExp} &::=& x  & \note{variable}\\
	       &&~|~& c  & \note{constant}\\
				 &&~|~& (\m{CoreHead}~\m{CoreExp}_1~\ldots~\m{CoreExp}_n) & \note{constructor}\\
	\\
	 &\m{SurfExp} &::=& x  & \note{variable}\\
	       &&~|~& c  & \note{constant}\\
				  % &&~|~& (\m{CoreHead}~\m{SurfExp}_1~\ldots~\m{SurfExp}_n) & \note{selected core constructor}\\
					 &&~|~& (\m{SurfHead}~\m{SurfExp}_1~\ldots~\m{SurfExp}_n) & \note{sugar expression}\\
	\end{array}
	\]
}

	\caption{Core and Surface Expressions}
	\label{fig:expression}
\end{figure}

As a preparation for our resugaring algorithm, we define a mixed language that combines a core language with a surface language (defined by syntactic sugars over the core language). An expression in this language is reduced step by step by the evaluation rules for the core language and the desugaring rules for the syntactic sugars in the surface language.

\subsubsection{Core Language}

For our core language,  its evaluator is driven by evaluation rules (context rules and reduction rules), with two natural assumptions. First, the evaluation is deterministic, in the sense that any expression in the core language will be reduced by a unique reduction sequence. Second, evaluation of a sub-expression has no side-effect on other parts of the expression.
%We discuss how to trickily extend our approach with a black-box stepper as the evaluator in Appendix.

An expression form of the core language is defined in Figure \ref{fig:expression}. It is a variable, a constant, or a (language) constructor expression. Here, $\m{CoreHead}$ stands for a language constructor such as $\m{if}$ and $\m{let}$. To be concrete, we will use a simplified core language defined in Figure \ref{fig:core} to demonstrate our approach.

\begin{figure}[thb]
\begin{centering}
	\[
	{\footnotesize
			\begin{array}{lcl}
			\m{CoreExp} &::=& \Code{(CoreExp~CoreExp~...)} ~~\note{// apply}\\
			&|& \m{(lambda~(x~...)~CoreExp)} ~~\note{// call-by-value}\\
			&|& \m{(lambdaN~(x~...)~CoreExp)} ~~\note{// call-by-need}\\
			&|& \m{(if~CoreExp~CoreExp~CoreExp)}\\
			&|& \m{(let~x~CoreExp~CoreExp)}\\
			&|& \m{(first~CoreExp)}\\
			&|& \m{(empty?~CoreExp)}\\
			&|& \m{(rest~CoreExp)}\\
			&|& \m{(cons~CoreExp~CoreExp)}\\
			&|& \m{(arithop~CoreExp~CoreExp)} ~~\note{// +, -, *, /, >, <, =}\\
			&|& \m{x}\\
			&|& \m{c} ~~\note{// boolean, number and list}
			\end{array}
	}
	\]
\end{centering}
\caption{A Core Language Example}
\label{fig:core}
\end{figure}


%For simplicity, we use the prefix notation. For instance, we write $\m{if-then-else}~e_1~e_2~e_3$, which would be more readable if we write $\m{if}~e_1~\m{then}~e_2~\m{else}~e_3$. In this paper, we may write both if it is clear from the context.

\subsubsection{Surface Language}

Our surface language is defined by a set of syntactic sugars, together with some basic elements in the core language, such as constant, variable. The surface language has expressions as given in Figure \ref{fig:expression}.

A syntactic sugar is defined by a desugaring rule in the following form:
\[
\drule{(\m{SurfHead}~e_1~e_2~\ldots~e_n)}{\m{exp}}
\]
where its LHS is a simple pattern (unnested) and its RHS is an expression of the surface language or the core language, and any pattern variable (e.g., $e_1$) in LHS only appears once in RHS. For instance, we may define syntactic sugar \m{and} by
\[
\drule{(\m{and}~e_1~e_2)}{(\m{if}~e_1~e_2~\false)}.
\]
Note that if the pattern is nested, we can introduce a new syntactic sugar to flatten it. And if we need to use a pattern variable multiple times in RHS, a \m{let} binding may be used (a normal way in syntactic sugar). We take the following sugar as an example
\[
\drule{(\m{Twice}~e_1)}{(+~e_1~e_1)}.
\]
If we execute \Code{(Twice (+ 1 1))}, it will firstly be desugared to \Code{(+ (+ 1 1) (+ 1 1))}, then reduced to \Code{(+ 2 (+ 1 1))} by one step. The subexpression \Code{(+ 1 1)} has been reduced but should not be resugared to the surface, because the other \Code{(+ 1 1)} has not been reduced yet.
%This would let many intermediate steps omitted, if there are many reduction steps between reduction of them.
So we just use a \m{let} binding to resolve this problem.

Note that in the desugaring rule, we do not restrict the RHS to be a $\m{CoreExp}$. We can use $\m{SurfExp}$ (more precisely, we allow the mixture use of syntactic sugars and core expressions) to define recursive syntactic sugars, as seen in the following example.
\[
\begin{array}{l}
\drule{(\m{Odd}~e)}{(\m{if}~(>~e~0)~(\m{Even}~(-~e~1))~\false)}\\
\drule{(\m{Even}~e)}{(\m{if}~(>~e~0)~(\m{Odd}~(-~e~1))~\true)}
\end{array}
\]

We assume that all desugaring rules are not overlapped in the sense that for a syntactic sugar expression, only one desugaring rule is applicable. \todo{inner sugar?}


\subsubsection{Mixed Language}
\begin{figure}[t]
\begin{centering}
{\footnotesize
\[
			\begin{array}{lcl}
			\m{Exp} &::=& \m{DisplayableExp}\\
			&|& \m{UndisplayableExp}\\
\\
			\m{DisplayableExp} &::=& \m{SurfExp}\\
			&|& \m{CommonExp}
\\
			\m{UndisplayableExp} &::=& \m{CoreExp'}\\
			&|& \m{OtherSurfExp}\\
			&|& \m{OtherCommonExp}\\
\\
			\m{CoreExp} &::=& \m{CoreExp'}\\
						 &|& \m{CommonExp}\\
						 &|& \m{OtherCommonExp}\\
\\
			\m{CoreExp'} &::=& (\m{CoreHead'}~\m{Exp}*)\\
\\
			\m{SurfExp} &::=& (\m{SurfHead}~\m{DisplayableExp}*)\\
\\
			\m{CommonExp} &::=& (\m{CommonHead}~\m{DisplayableExp}*)\\
			&|& c \qquad \note{// constant value}\\
			&|& x \qquad \note{// variable} \\
\\
			\m{OtherSurfExp} &::=& (\m{SurfHead}~\m{Exp}*~\m{UndisplayableExp}~\m{Exp}*)\\
\\
			\m{OtherCommonExp} &::=& (\m{CommonHead}~\m{Exp}*~\m{UndisplayableExp}~\m{Exp}*)
			\end{array}
			\]
}

\end{centering}
\caption{Our Mixed Language}
\label{fig:mix}
\end{figure}

Our mixed language for resugaring combines the surface language and the core language, described in Figure \ref{fig:mix}.
%
The differences between expressions in our core language and those in our surface language are only identified by their \m{Head}. But there may be some expressions in the core language which are also used in the surface language for convenience, or we need some core language's expressions to help us getting better resugaring sequences. So we separate \m{CommonHead} from the \m{CoreHead}, which can be displayed in resugaring sequences (the rest of \m{CoreHead} becomes \m{CoreHead'}). The \m{CoreExp'} is the expression with undisplayable \m{CoreHead} (named \m{CoreHead'}). The \m{SurfExp} is the expression with \m{SurfHead} and all subexpressions are displayable. The \m{CommonExp} is the expression with displayable CoreLang's \m{Head} (named \m{CommonHead}), together with displayable subexpressions. There exists some other expressions during our resugaring process, which have displayable \m{Head}, but one or more subexpressions should not display. They are of \m{UndisplayableExp}. We distinct the two kinds of expression for \emph{abstraction} property (discussed in Section \ref{mark:abs}).

Take some expressions in the core language in Figure \ref{fig:core} as examples.
We may assume \m{if}, \m{let}, \m{lambdaN} (call-by-name lambda calculus), \m{empty?}, \m{first}, \m{rest} as \m{CoreHead'}, \m{op}, \m{lambda} (call-by-value lambda calculus), \m{cons} as \m{CommonHead}. Then we would show some useful intermediate steps.

Note that some expressions with \m{CoreHead} contain subexpressions with \m{SurfHead}, they are of \m{CoreExp} but not in core language. In the mixed language, we process these expression by core language's context rule, and the reduction rules of core language and the desugaring rules of surface language are mixed as a whole (the $\redc{}{}$ in next section). For example, we have the context rule of \m{if} expression
\[
\infer{(\m{if}~e_1~e_2~e_3) \rightarrow (\m{if}~e_1'~e_2~e_3)}{e_1 \rightarrow e_1'}
\]
then if $e_1$ is a expression in core language, it will reduce by the reduction rule in core language; if $e_1$ is a \m{SurfExp}, it will reduce by the desugaring rule of $e_1$'s \m{Head} (how the subexpression reduced does not matter, because it is just to mark the location where should be reduced); if $e_1$ is also a \m{CoreExp} with non-core subexpressions, a recursive reduction by $\redc{}{}$ is needed.


\subsection{Resugaring Algorithm}

Our resugaring algorithm works on our mixed language, based on the evaluator of the core language and the desugaring rules for defining the surface language. Let $\redc{}{}$ denote the one-step reduction of the \m{CoreExp} (described in previous section), and $\drule{}{}$ the one-step desugaring of outermost sugar. We define $\redm{}{}$, the one-step reduction of our mixed language, as follows.
\label{mark:mixedreduction}
\infrule[CoreRed1]
{\redm{e_i}{e_i''}\\
\exists i.\, \redc{(\m{CoreHead}~e_1~\ldots~e_i~\ldots~e_n)}{(\m{CoreHead}~e_1~\ldots~e_i'~\ldots~e_n)}~and~e_i~\in~\m{SurfExp}}
{\redm{(\m{CoreHead}~e_1~\ldots~e_i~\ldots~e_n)}{(\m{CoreHead}~e_1~\ldots~e_i''~\ldots~e_n)}}
\infrule[CoreRed2]
{\redc{(\m{CoreHead}~e_1~\ldots~e_n)}{e'}\\
\neg \exists i.\, \redc{(\m{CoreHead}~e_1~\ldots~e_i~\ldots~e_n)}{(\m{CoreHead}~e_1~\ldots~e_i'~\ldots~e_n)}~and~e_i~\in~\m{SurfExp}}
{\redm{(\m{CoreHead}~e_1~\ldots~e_i~\ldots~e_n)}{e'}}
\infrule[SurfRed1]
{\drule{(\m{SurfHead}~x_1~\ldots~x_i~\ldots~x_n)}{e},~\redm{e_i}{e_i''}\\
\exists i.\, \redm{e[e_1/x,\ldots,e_i/x_i,\ldots,e_n/x_n]}{e[e_1/x,\ldots,e_i'/x_i,\ldots,e_n/x_n]}
}
{\redm{(\m{SurfHead}~e_1~\ldots~e_i~\ldots~e_n)}{(\m{SurfHead}~e_1~\ldots~e_i''~\ldots~e_n)}}
\infrule[SurfRed2]
{\drule{(\m{SurfHead}~x_1~\ldots~x_i~\ldots~x_n)}{e}\\
\neg \exists i.\, \redm{e[e_1/x_1,\ldots,e_i/x_i,\ldots,e_n/x_n]}{e[e_1/x_1,\ldots,e_i'/x_i,\ldots,e_n/x_n]}
}
{\redm{(\m{SurfHead}~e_1~\ldots~e_i~\ldots~e_n)}{e[e_1/x_1,\ldots,e_i/x_i,\ldots,e_n/x_n]}
}

Putting them in simple words. For the expression with \m{CoreHead}, we just use the evaluation rules of core language combined with desugaring rules as reduction rules. As described in the previous section, if a \m{SurfExp} subexpression is reduced (\m{CoreRed1}), we should mark the location and apply $\redm{}{}$ on it recursively. Otherwise (\m{CoreRed2}), the expression just reduces by the $\redc{}{}$'s rules.
For the expression with \m{SurfHead}, we will first expand the outermost sugar (identified by the \m{SurfHead}), then recursively apply $\redm{}{}$ on the partly desugared expression. In the recursive call, if one of the original subexpression $e_i$ is reduced (rule \m{SurfRed1}), then the original sugar is not necessarily desugared, we should only reduce the subexpression $e_i$; if not (rule \m{SurfRed2}), then the sugar have to desugar.


%\todo{Add explanantion of the above rule.}

Then our desugaring algorithm is defined based on $\redm{}{}$.

\[
\begin{array}{llll}
\m{resugar} (e) &=& \key{if}~\m{isNormal}(e)~\key{then}~return\\
              & & \key{else}~\\
							& & \qquad \key{let}~\redm{e}{e'}~\key{in}\\
							& & \qquad \key{if}~e' \in~\m{DisplayableExp} \\
							& & \qquad \qquad \m{output}(e'),~\m{resugar}(e')\\
							& & \qquad \key{else}~\m{resugar}(e')
\end{array}
\]

During the resugaring, we just call the mixed language's reduction ($\redm{}{}$) on the input expression until the expression becomes a normal form. We use the \m{DisplayableExp} to restrict immediate sequences to be output or not. It is more explicit compared to the traditional approach. And because $\redm{}{}$ will be executed recursively on the subexpressions, it can be optimized (see in \ref{mark:optimize}, because the current description is easier to understand.)

\subsection{Correctness}
\label{mark:correct}

Traditional resugaring approach\cite{resugaring,hygienic} define three properties for the correctness of resugaring. We think they are also reasonable to describe the correctness of our approach. We describe the following properties in our mixed language's domain, then prove or discuss them.

\emph{Emulation.} For each reduction of an expression in our mixed language, it should reflect on one-step reduction of the expression totally desugared in the core language, or one step desugaring on a syntactic sugar.

\emph{Abstraction.} Only displayable expressions defined in our mixed language appear in our resugaring sequences.

\emph{Coverage.} No syntactic sugar is desugared before its sugar structure should be destroyed in core language.

\subsubsection{Emulation} It is a basic property for correctness. Since desugaring does not change an expression after totally desugared, what we need to prove is that a non-desugaring reduction in the mixed language shows the exact reduction which should appear after the expression totally desugared. Formalize by the following lemma (\m{fulldesugar}(\m{exp}) returns the expression after \m{exp} totally desugared).

\begin{lemma}
\label{lemma1}

For~\m{exp} = $(\m{SurfHead}~e_1~\ldots~e_i~\ldots~e_n)\in\m{SurfExp}$, if~$\redm{\m{exp}}{\m{exp'}}$ and\\ \m{fulldesugar}(\m{exp}) $\not=$ $\m{fulldesugar}(\m{exp'})$,~then $\redc{\m{fulldesugar}(\m{exp})}{\m{fulldesugar}(\m{exp'})}$

\end{lemma}

\begin{Def}[Emulation]
If the mixed language satisfies Lemma \ref{lemma1}, then the resugaring satisfies emulation property.
\end{Def}

\begin{lemma}
\label{lemma2}

For~\m{exp} = $(\m{SurfHead}~e_1~\ldots~e_i~\ldots~e_n)$, if inputting $\m{fulldesugar}(\m{exp})$ to core language's evaluator reduces the expression original from $e_i$ in one step, then $\redm{}{}$ will reduce \m{exp} at $e_i$.

%then $\redc{\m{fulldesugar}(\m{Exp})}{\m{fulldesugar}(\m{Exp'})}$
\end{lemma}

\begin{proof}[Proof of Lemma \ref{lemma2}]
For $\drule{(\m{SurfHead}~x_1~\ldots~x_i~\ldots~x_n)}{e}$,

If $e$ is of normal form, the $\m{fulldesugar}(\m{exp})$ will not be reduced by core evaluator.

If $e$ is headed with \m{CoreHead}, then according to the \m{CoreRed} rule, the $\rede{}{}$ will apply on $e$ according to \m{CoreRed1} or \m{CoreRed2}, which will reduce the subexpression $e_i$ according to the context rule of core language. Then the \m{SurfRed2} rule will reduce $e_i$. Because of the context rule, reduction of the subexpression is in correct location, so it is for $\redm{}{}$.

If $e$ is headed with \m{SurfHead}, then the $\redm{}{}$ will apply recursively on $e$. If the new one satisfies the lemma, then it is for the former. Because any sugar expression will finally be able to desugar to an expression with \m{CoreHead}, it can be proved recursively.
\end{proof}
\begin{proof}[Proof of Lemma \ref{lemma1}]
We need to prove both \m{SurfRed1} and \m{SurfRed2} satisfy it.
For \m{SurfRed1} rule, $\redm{(\m{SurfHead}~e_1~\ldots~e_i~\ldots~e_n)}{(\m{SurfHead}~e_1~\ldots~e_i''$$\ldots~e_n)}$, where $\redm{e_i}{e_i''}$.
If $\m{fulldesugar}(e_i)$ = $\m{fulldesugar}(e_i'')$, then \m{fulldesugar}(\m{Exp}) = \m{fulldesugar}(\m{Exp'}). If not,  what we need to prove is that, $\redc{\m{fulldesugar}(\m{Exp})}{\m{fulldesugar}(\m{Exp'})}$. Note that the only difference between \m{Exp} and \m{Exp'} is the i-th subexpression, and we have proved the lemma \ref{lemma2} that the subexpression is the one to be reduced after the expression desugared totally, it will be also a recursive proof on the subexpression $e_i$.

For \m{SurfRed2} rule, \m{Exp'} is \m{Exp} after the outermost sugar desugared. So the expressions after totally desugared are equal, \m{fulldesugar}(\m{Exp}) =
\m{fulldesugar}(\m{Exp'}).
\end{proof}

In summary, our resugaring approach satisfies emulation property.

\subsubsection{Abstraction}
\label{mark:abs}

Abstraction is not a restrict properties, because each expression has its meaning. Users may choose what they want to output during the process. Traditional resugaring approaches use marks to determine whether to display an expression generated by desugaring, or only changes on original expressions will show.

We define the abstraction by catalog the expressions in the mixed language, from the reason why we need resugaring---sugar expressions become unrecognizable after desugaring. So why cannot a recursive sugar's resugaring sequences show the sugars generated by itself? We think the users should be allowed to decide which expressions are recognizable. Then during the resugaring process, if no unrecognizable expression for the user appears in the whole expression, the expression should be shown as a step in resugaring sequences. Lazy resugaring, as the key idea of our approach, makes any intermediate steps retain as many sugar structures as possible, so the abstraction is easy.

One may ask what if we just want to display core language's expression originated from the input expression. The solution is that we can write surface mirror term for core expressions. For example, if we want to show resugaring sequences of \Code{(and (if (and \#t \#f) ...) ...)} without displaying \m{if} expression produced by \m{and}, we can write a \m{IF} term, with the same evaluation rules as \m{if}. Then just input \Code{(and (IF (and \#t \#f) ...) ...)} to get the resugaring sequences. It is really flexible.

\subsubsection{Coverage}
The coverage property is important, because resugaring sequences are useless if losing intermediate steps. By lazy desugaring, it becomes obvious, because there is no chance to lose. In Lemma \ref{lemma3}, we want to show that our reduction rules in the mixed language is \emph{lazy} enough. Because it is obvious, we only give a proof sketch here.
\begin{lemma}
\label{lemma3}
A syntactic sugar only desugars when \emph{necessary}, that means after a reduction on the fully-desugared expression, the sugar's structure is destroyed.
\end{lemma}

\begin{Def}[Coverage]
If the reduction of mixed language satisfies Lemma \ref{lemma3}, then the resugaring satisfies coverage property.
\end{Def}



\begin{proof}[Proof sketch of Lemma \ref{lemma3}]
From Lemma \ref{lemma2}, we know the $\redm{}{}$ recursively reduces an expression at correct subexpression, or the $\redm{}{}$ will expand the outermost sugar (of the current expression) in rule \m{SurfRed2}. Note that it is the only rule to desugar sugars directly (other rules only desugar sugars when recursively call \m{SurfRed2}), we can prove the lemma recursively if \m{SurfRed2} are \emph{lazy} enough.

In \m{SurfRed2} rule, we firstly expand the outermost sugar and get a temp expression with the structure of the outermost sugar. Then when we recursively call $\redm{}{}$, the reduction result shows the structure has been destroyed, so the outermost sugar has to be desugared. Since the recursive reduction of a terminable (some bad sugars may never stop which are pointless) sugar expression will finally terminate, the lemma can be proved recursively.
\end{proof}
